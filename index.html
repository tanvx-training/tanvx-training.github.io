<!DOCTYPE html>
<html lang="vi">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Hướng dẫn Tương tác - Spring Professional Certification</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Be+Vietnam+Pro:wght@300;400;500;600;700&display=swap" rel="stylesheet">
    <!-- Chosen Palette: "Warm Neutral Harmony" -->
    <!-- Application Structure Plan: Ứng dụng được cấu trúc với một thanh điều hướng chính cố định bên trái liệt kê các lĩnh vực thi chính. Mỗi lĩnh vực có các tab điều hướng phụ ở trên cùng để chia nhỏ các chủ đề phức tạp. Cấu trúc này giúp người dùng dễ dàng điều hướng, tập trung vào từng khái niệm cụ thể và tránh quá tải thông tin so với việc đọc một tài liệu dài. Người dùng có thể chuyển đổi giữa các lĩnh vực lớn và các chủ đề chi tiết một cách linh hoạt. -->
    <!-- Visualization & Content Choices: 
        1. So sánh các loại Dependency Injection: Mục tiêu -> So sánh. Phương pháp -> Biểu đồ cột ngang (Chart.js) để trực quan hóa các tiêu chí như Khả năng kiểm thử, Tính bất biến. Tương tác -> Hover để xem tooltip chi tiết. Lý do -> Biểu đồ giúp nhận diện ưu/nhược điểm nhanh hơn bảng văn bản.
        2. Bean Scopes: Mục tiêu -> Tổ chức & Thông báo. Phương pháp -> Bố cục thẻ tương tác (HTML/CSS). Tương tác -> Nhấp vào thẻ để xem chi tiết, ví dụ và các lưu ý. Lý do -> Chia nhỏ thông tin dày đặc thành các phần hấp dẫn, dễ tiêu hóa.
        3. Thứ tự thực thi Advice trong AOP: Mục tiêu -> Giải thích quy trình. Phương pháp -> Sơ đồ trực quan bằng HTML/CSS. Tương tác -> Hover vào các bước để xem mô tả chi tiết. Lý do -> Sơ đồ dòng chảy hiệu quả hơn văn bản thuần túy trong việc giải thích một chuỗi sự kiện.
        4. Code Snippets: Mục tiêu -> Cung cấp thông tin. Phương pháp -> Khối mã được định dạng rõ ràng với nút sao chép. Tương tác -> Nút "Sao chép". Lý do -> Cải thiện tính dễ đọc và khả năng tái sử dụng.
        Các lựa chọn này tuân thủ yêu cầu sử dụng Canvas cho biểu đồ và HTML/CSS cho các sơ đồ, không sử dụng SVG/Mermaid. -->
    <!-- CONFIRMATION: NO SVG graphics used. NO Mermaid JS used. -->
    <style>
        body {
            font-family: 'Be Vietnam Pro', sans-serif;
            background-color: #F5F5F4; /* stone-100 */
        }
        ::-webkit-scrollbar {
            width: 8px;
        }
        ::-webkit-scrollbar-track {
            background: #E7E5E4; /* stone-200 */
        }
        ::-webkit-scrollbar-thumb {
            background: #A8A29E; /* stone-400 */
            border-radius: 10px;
        }
        ::-webkit-scrollbar-thumb:hover {
            background: #78716C; /* stone-500 */
        }
        .main-content h2 {
            font-size: 1.875rem;
            font-weight: 700;
            color: #1C1917; /* stone-900 */
            margin-bottom: 1.5rem;
            padding-bottom: 0.5rem;
            border-bottom: 2px solid #D6D3D1; /* stone-300 */
        }
        .main-content h3 {
            font-size: 1.5rem;
            font-weight: 600;
            color: #292524; /* stone-800 */
            margin-top: 2rem;
            margin-bottom: 1rem;
        }
        .main-content p, .main-content li {
            color: #44403C; /* stone-700 */
            line-height: 1.75;
        }
        .main-content a {
            color: #2563EB; /* blue-600 */
            text-decoration: underline;
        }
        .main-content .code-block {
            background-color: #1f2937; /* gray-800 */
            color: #d1d5db; /* gray-300 */
            padding: 1rem;
            border-radius: 0.5rem;
            margin: 1rem 0;
            position: relative;
            overflow-x: auto;
        }
        .main-content .copy-btn {
            position: absolute;
            top: 0.5rem;
            right: 0.5rem;
            background-color: #4b5563; /* gray-600 */
            color: white;
            border: none;
            padding: 0.25rem 0.5rem;
            border-radius: 0.25rem;
            cursor: pointer;
            font-size: 0.75rem;
        }
        .main-content .copy-btn:hover {
            background-color: #6b7280; /* gray-500 */
        }
        .main-content .note {
            background-color: #FEFCE8; /* yellow-50 */
            border-left: 4px solid #FACC15; /* yellow-400 */
            padding: 1rem;
            margin: 1.5rem 0;
            border-radius: 0.25rem;
        }
         .chart-container { 
            position: relative; 
            width: 100%; 
            max-width: 700px; 
            margin-left: auto; 
            margin-right: auto; 
            height: 350px; 
            max-height: 40vh;
        }
        .main-nav-item.active {
            background-color: #FFFFFF;
            color: #1C1917;
            font-weight: 600;
        }
        .sub-nav-item.active {
            border-bottom-color: #3B82F6; /* blue-500 */
            color: #3B82F6;
            font-weight: 600;
        }
    </style>
</head>
<body class="text-stone-800">

    <div class="flex h-screen bg-stone-100">
        <!-- Sidebar Navigation -->
        <aside id="sidebar" class="w-64 bg-stone-200 p-4 flex-shrink-0 overflow-y-auto transition-transform transform -translate-x-full md:translate-x-0 md:relative">
            <h1 class="text-2xl font-bold text-stone-900 mb-6 border-b border-stone-300 pb-4">Spring Cert Guide</h1>
            <nav id="main-nav">
                <!-- Main navigation links will be inserted here by JS -->
            </nav>
        </aside>

        <!-- Mobile Menu Button -->
        <button id="menu-toggle" class="md:hidden fixed top-4 left-4 z-20 p-2 bg-white rounded-md shadow-md">
            <svg xmlns="http://www.w3.org/2000/svg" class="h-6 w-6" fill="none" viewBox="0 0 24 24" stroke="currentColor">
                <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M4 6h16M4 12h16m-7 6h7" />
            </svg>
        </button>

        <!-- Main Content -->
        <main class="flex-1 p-4 sm:p-6 lg:p-8 overflow-y-auto">
            <div id="content-container" class="max-w-7xl mx-auto">
                <!-- Content will be inserted here by JS -->
            </div>
        </main>
    </div>

<script>
const contentData = {
    'intro': {
        title: 'Chào mừng đến với Hướng dẫn Tương tác Spring Certification',
        content: `
            <h2>Bắt đầu hành trình chinh phục Spring</h2>
            <p class="mt-4 text-lg">Chứng chỉ Spring Professional xác nhận sự hiểu biết sâu sắc về các khái niệm cốt lõi của Spring Framework và khả năng áp dụng chúng vào phát triển ứng dụng thực tế. Hướng dẫn này được thiết kế để cung cấp một trải nghiệm học tập tương tác, giúp bạn nắm vững kiến thức một cách có hệ thống và hiệu quả.</p>
            <p class="mt-4">Hãy bắt đầu bằng cách chọn một lĩnh vực từ thanh điều hướng bên trái. Mỗi lĩnh vực bao gồm các chủ đề chi tiết, được trình bày dưới dạng các tab để bạn dễ dàng theo dõi. Các khái niệm phức tạp sẽ được minh họa bằng sơ đồ và biểu đồ tương tác để giúp bạn hiểu sâu hơn.</p>
            <div class="mt-8 grid grid-cols-1 md:grid-cols-2 gap-6">
                <div class="bg-white p-6 rounded-lg shadow-sm">
                    <h3 class="font-semibold text-blue-600">Học tập có cấu trúc</h3>
                    <p>Nội dung được chia thành các lĩnh vực chính của kỳ thi, giúp bạn tập trung vào từng phần một.</p>
                </div>
                <div class="bg-white p-6 rounded-lg shadow-sm">
                    <h3 class="font-semibold text-green-600">Trực quan hóa</h3>
                    <p>Các biểu đồ và sơ đồ tương tác giúp làm sáng tỏ các khái niệm trừu tượng và các mối quan hệ phức tạp.</p>
                </div>
            </div>
        `
    },
    'container': {
        title: 'I. Container, Dependency, và IoC',
        subtopics: {
            'ioc': {
                title: 'IoC Container',
                content: `
                    <h3>Giới thiệu về Spring IoC Container</h3>
                    <p>Spring IoC (Inversion of Control) container là trái tim của Spring Framework, chịu trách nhiệm quản lý vòng đời và các dependency của Spring bean. Container tự động khởi tạo, cấu hình và lắp ráp các bean dựa trên cấu hình được cung cấp.</p>
                    <p class="mt-2">Sự thay đổi cơ bản mà IoC mang lại là việc đảo ngược quyền kiểm soát từ nhà phát triển sang framework. Thay vì mã của bạn tạo và quản lý đối tượng, container sẽ làm điều đó, giúp giảm sự phụ thuộc, tăng khả năng kiểm thử và cải thiện khả năng bảo trì.</p>
                    <h4 class="text-xl font-semibold mt-6 mb-2">Các loại Container</h4>
                    <ul class="list-disc list-inside space-y-2">
                        <li><strong>BeanFactory:</strong> Container đơn giản nhất, cung cấp các tính năng cơ bản của Dependency Injection. Nó nhẹ và thường khởi tạo bean một cách "lười biếng" (lazy initialization) khi được yêu cầu.</li>
                        <li><strong>ApplicationContext:</strong> Một container nâng cao hơn, xây dựng trên BeanFactory. Nó bổ sung nhiều chức năng cấp doanh nghiệp như tích hợp AOP, xử lý sự kiện, và quốc tế hóa. Các bean thường được tạo ngay khi khởi động (eager initialization). Trong hầu hết các ứng dụng, ApplicationContext là lựa chọn ưu tiên.</li>
                    </ul>
                `
            },
            'bean-def': {
                title: 'Định nghĩa Bean',
                content: `
                    <h3>Định nghĩa Bean: XML, Annotation, và Java Config</h3>
                    <p>Spring cung cấp ba cách chính để định nghĩa các bean và cấu hình chúng:</p>

                    <h4 class="text-xl font-semibold mt-6 mb-2">1. Cấu hình XML</h4>
                    <p>Phương pháp truyền thống, định nghĩa bean trong các tệp XML. Mặc dù ít phổ biến hơn hiện nay, nó vẫn hữu ích cho các dự án lớn hoặc hệ thống cũ nơi việc quản lý tập trung là cần thiết.</p>
                    <div class="code-block">
                        <pre><code>&lt;bean id="myBean" class="com.example.MyBean"&gt;
    &lt;property name="name" value="Example Bean"/&gt;
&lt;/bean&gt;</code></pre>
                    </div>

                    <h4 class="text-xl font-semibold mt-6 mb-2">2. Cấu hình bằng Annotation</h4>
                    <p>Cách tiếp cận hiện đại và phổ biến nhất. Các lớp được đánh dấu bằng các annotation stereotype để Spring tự động phát hiện và đăng ký chúng làm bean.</p>
                    <ul class="list-disc list-inside space-y-2">
                        <li><code>@Component</code>: Annotation chung cho bất kỳ bean nào được quản lý bởi Spring.</li>
                        <li><code>@Service</code>: Dành cho lớp tầng dịch vụ (business logic).</li>
                        <li><code>@Repository</code>: Dành cho lớp tầng truy cập dữ liệu (DAO), cung cấp tính năng dịch ngoại lệ.</li>
                        <li><code>@Controller</code>: Dành cho các controller trong Spring MVC.</li>
                    </ul>
                    <div class="code-block">
                        <pre><code>@Component("myBean")
public class MyBean {
    @Value("Example Bean")
    private String name;
}</code></pre>
                    </div>
                    <p>Để kích hoạt quét annotation, bạn cần sử dụng <code>@ComponentScan</code> trong lớp cấu hình của mình.</p>

                    <h4 class="text-xl font-semibold mt-6 mb-2">3. Cấu hình Java (Java Configuration)</h4>
                    <p>Sử dụng các lớp Java thuần túy để định nghĩa bean. Đây là một cách tiếp cận an toàn về kiểu và linh hoạt.</p>
                    <ul class="list-disc list-inside space-y-2">
                        <li><code>@Configuration</code>: Đánh dấu một lớp là nguồn định nghĩa bean.</li>
                        <li><code>@Bean</code>: Đánh dấu một phương thức trong lớp <code>@Configuration</code> là phương thức nhà máy (factory method) để tạo ra một bean.</li>
                    </ul>
                    <div class="code-block">
                        <pre><code>@Configuration
public class AppConfig {
    @Bean
    public MyBean myBean() {
        MyBean bean = new MyBean();
        bean.setName("Example Bean");
        return bean;
    }
}</code></pre>
                    </div>
                `
            },
            'bean-scope': {
                title: 'Phạm vi Bean',
                content: `
                    <h3>Phạm vi Bean (Bean Scopes)</h3>
                    <p>Phạm vi của bean xác định vòng đời và khả năng hiển thị của một instance bean. Việc chọn đúng phạm vi là rất quan trọng để quản lý trạng thái và tài nguyên hiệu quả. Nhấp vào từng thẻ để tìm hiểu chi tiết.</p>
                    <div id="bean-scopes-container" class="mt-6 grid grid-cols-1 md:grid-cols-2 lg:grid-cols-3 gap-4">
                        <!-- Bean scope cards will be inserted here by JS -->
                    </div>
                    <div id="bean-scope-details" class="mt-6 bg-white p-6 rounded-lg shadow-sm hidden">
                        <!-- Details will be shown here -->
                    </div>
                     <div class="note">
                        <p><strong>Thách thức phổ biến:</strong> Khi một bean có phạm vi tồn tại lâu hơn (ví dụ: <code>singleton</code>) phụ thuộc vào một bean có phạm vi ngắn hơn (ví dụ: <code>request</code>), Spring sẽ inject một proxy AOP thay vì đối tượng thực. Proxy này sẽ lấy instance bean thực sự từ phạm vi tương ứng (ví dụ: yêu cầu HTTP hiện tại) mỗi khi một phương thức được gọi.</p>
                    </div>
                `
            },
            'lifecycle': {
                title: 'Vòng đời Bean',
                content: `
                    <h3>Vòng đời Bean: Callback và Thứ tự thực thi</h3>
                    <p>Vòng đời của Spring bean định nghĩa một chuỗi các giai đoạn mà một bean trải qua từ khi được tạo cho đến khi bị hủy. Việc hiểu rõ vòng đời này giúp quản lý tài nguyên (như kết nối cơ sở dữ liệu) một cách chính xác.</p>
                    <h4 class="text-xl font-semibold mt-6 mb-2">Các giai đoạn chính</h4>
                    <ol class="list-decimal list-inside space-y-2">
                        <li><strong>Instantiation:</strong> Container tạo một instance của lớp bean.</li>
                        <li><strong>Populate Properties:</strong> Container inject các dependency (DI).</li>
                        <li><strong>Initialization:</strong> Các callback khởi tạo được gọi. Đây là nơi để thực hiện logic thiết lập tùy chỉnh.</li>
                        <li><strong>In Use:</strong> Bean sẵn sàng để sử dụng.</li>
                        <li><strong>Destruction:</strong> Khi container đóng, các callback hủy được gọi để giải phóng tài nguyên.</li>
                    </ol>

                    <h4 class="text-xl font-semibold mt-6 mb-2">Thứ tự thực thi Callback</h4>
                    <div class="grid grid-cols-1 md:grid-cols-2 gap-6">
                        <div>
                            <h5 class="font-semibold">Khởi tạo (Initialization)</h5>
                            <ol class="list-decimal list-inside space-y-1 mt-2">
                                <li>Phương thức được chú thích bằng <code>@PostConstruct</code> (tiêu chuẩn JSR-250, được khuyến nghị).</li>
                                <li>Phương thức <code>afterPropertiesSet()</code> từ interface <code>InitializingBean</code>.</li>
                                <li>Phương thức <code>init-method</code> tùy chỉnh được định nghĩa trong XML hoặc <code>@Bean</code>.</li>
                            </ol>
                        </div>
                        <div>
                            <h5 class="font-semibold">Hủy (Destruction)</h5>
                            <ol class="list-decimal list-inside space-y-1 mt-2">
                                <li>Phương thức được chú thích bằng <code>@PreDestroy</code> (tiêu chuẩn JSR-250, được khuyến nghị).</li>
                                <li>Phương thức <code>destroy()</code> từ interface <code>DisposableBean</code>.</li>
                                <li>Phương thức <code>destroy-method</code> tùy chỉnh.</li>
                            </ol>
                        </div>
                    </div>
                    <div class="note">
                        <p><strong>Khuyến nghị:</strong> Nên ưu tiên sử dụng các annotation <code>@PostConstruct</code> và <code>@PreDestroy</code> vì chúng là một phần của tiêu chuẩn Java và không ràng buộc mã của bạn với các interface cụ thể của Spring.</p>
                    </div>
                `
            },
            'di': {
                title: 'Dependency Injection',
                content: `
                    <h3>Dependency Injection (DI)</h3>
                    <p>Dependency Injection (DI) là một mẫu thiết kế nơi các dependency của một đối tượng được "tiêm" vào nó bởi một thực thể bên ngoài (container), thay vì đối tượng tự tạo ra chúng. Spring hỗ trợ ba loại DI chính.</p>
                    
                    <h4 class="text-xl font-semibold mt-6 mb-2">So sánh các loại Dependency Injection</h4>
                    <p>Biểu đồ dưới đây so sánh ba loại DI dựa trên các tiêu chí quan trọng. Constructor Injection thường là lựa chọn tốt nhất cho các dependency bắt buộc.</p>
                    <div class="chart-container my-6">
                        <canvas id="diComparisonChart"></canvas>
                    </div>

                    <div id="di-details-container" class="space-y-6">
                        <div>
                            <h5 class="font-semibold text-lg">1. Constructor Injection (Được khuyến nghị)</h5>
                            <p>Các dependency được cung cấp thông qua hàm tạo của lớp. Điều này đảm bảo đối tượng luôn được tạo ở trạng thái hợp lệ với tất cả các dependency cần thiết và cho phép các trường dependency là <code>final</code>, thúc đẩy tính bất biến.</p>
                             <div class="code-block">
                                <pre><code>@Component
public class MyService {
    private final MyRepository repository;

    @Autowired // Tùy chọn nếu chỉ có một constructor
    public MyService(MyRepository repository) {
        this.repository = repository;
    }
}</code></pre>
                            </div>
                        </div>
                        <div>
                            <h5 class="font-semibold text-lg">2. Setter Injection</h5>
                            <p>Các dependency được cung cấp thông qua các phương thức setter. Hữu ích cho các dependency tùy chọn có thể được thay đổi sau khi đối tượng được tạo.</p>
                             <div class="code-block">
                                <pre><code>@Component
public class MyService {
    private MyRepository repository;

    @Autowired
    public void setRepository(MyRepository repository) {
        this.repository = repository;
    }
}</code></pre>
                            </div>
                        </div>
                        <div>
                            <h5 class="font-semibold text-lg">3. Field Injection (Không khuyến khích)</h5>
                            <p>Các dependency được tiêm trực tiếp vào các trường. Mặc dù ngắn gọn, nó làm cho việc kiểm thử đơn vị trở nên khó khăn hơn (vì cần reflection để đặt các mock) và che giấu các dependency của lớp.</p>
                             <div class="code-block">
                                <pre><code>@Component
public class MyService {
    @Autowired
    private MyRepository repository;
}</code></pre>
                            </div>
                        </div>
                    </div>

                    <h3 class="mt-8">Giải quyết xung đột Dependency</h3>
                    <p>Khi có nhiều bean cùng loại, Spring cần sự trợ giúp để biết nên inject bean nào. Có hai cách chính để giải quyết sự mơ hồ này:</p>
                    <ul class="list-disc list-inside space-y-2 mt-4">
                        <li><code>@Qualifier("beanName")</code>: Chỉ định rõ ràng tên của bean cần inject. Được sử dụng cùng với <code>@Autowired</code>.</li>
                        <li><code>@Primary</code>: Đánh dấu một bean là lựa chọn ưu tiên khi có nhiều ứng viên. Nếu một bean được đánh dấu <code>@Primary</code>, nó sẽ được chọn theo mặc định.</li>
                    </ul>
                `
            },
            'bpp': {
                title: 'Bean Post Processors',
                content: `
                    <h3>Bean Post Processors</h3>
                    <p><code>BeanPostProcessor</code> là một interface đặc biệt cho phép bạn cắm logic tùy chỉnh vào quá trình khởi tạo bean của Spring. Nó cung cấp các hook để xử lý các instance bean trước và sau khi các phương thức khởi tạo của chúng được gọi.</p>
                    <p class="mt-2">Đây là một cơ chế mở rộng cực kỳ mạnh mẽ. Nhiều tính năng của Spring, chẳng hạn như AOP (tạo proxy), quản lý giao dịch (<code>@Transactional</code>), và bảo mật, được triển khai nội bộ bằng cách sử dụng <code>BeanPostProcessor</code>.</p>
                    <h4 class="text-xl font-semibold mt-6 mb-2">Các phương thức chính</h4>
                    <ul class="list-disc list-inside space-y-2">
                        <li><code>postProcessBeforeInitialization(Object bean, String beanName)</code>: Được gọi <strong>trước</strong> khi bất kỳ callback khởi tạo nào (như <code>@PostConstruct</code> hoặc <code>init-method</code>) được thực thi.</li>
                        <li><code>postProcessAfterInitialization(Object bean, String beanName)</code>: Được gọi <strong>sau</strong> khi tất cả các callback khởi tạo đã hoàn tất.</li>
                    </ul>
                     <div class="note">
                        <p>Một <code>BeanPostProcessor</code> hoạt động trên tất cả các bean trong container. Nó được thiết kế để áp dụng logic cắt ngang (cross-cutting) cho một tập hợp các bean, khác với các callback vòng đời (như <code>@PostConstruct</code>) chỉ áp dụng cho một bean duy nhất.</p>
                    </div>
                `
            }
        }
    },
    'aop': {
        title: 'II. Aspect-Oriented Programming (AOP)',
        subtopics: {
            'concepts': {
                title: 'Khái niệm AOP',
                content: `
                    <h3>Các khái niệm cốt lõi của AOP</h3>
                    <p>Lập trình hướng khía cạnh (AOP) cho phép bạn mô-đun hóa các mối quan tâm cắt ngang (cross-cutting concerns) — các chức năng ảnh hưởng đến nhiều phần của ứng dụng, chẳng hạn như ghi nhật ký (logging), bảo mật, và quản lý giao dịch. AOP giúp tách biệt các chức năng này khỏi logic nghiệp vụ cốt lõi.</p>
                    <div class="mt-6 space-y-4">
                        <div class="bg-white p-4 rounded-lg shadow-sm">
                            <h4 class="font-bold text-lg">Aspect</h4>
                            <p>Một module chứa code cho một mối quan tâm cắt ngang. Trong Spring, một aspect là một lớp được chú thích bằng <code>@Aspect</code>.</p>
                        </div>
                        <div class="bg-white p-4 rounded-lg shadow-sm">
                            <h4 class="font-bold text-lg">Join Point</h4>
                            <p>Một điểm cụ thể trong quá trình thực thi của chương trình. Trong Spring AOP, một join point luôn là việc thực thi một phương thức.</p>
                        </div>
                        <div class="bg-white p-4 rounded-lg shadow-sm">
                            <h4 class="font-bold text-lg">Advice</h4>
                            <p>Hành động được thực hiện bởi một aspect tại một join point. Ví dụ, ghi lại một thông điệp log trước khi một phương thức được thực thi.</p>
                        </div>
                        <div class="bg-white p-4 rounded-lg shadow-sm">
                            <h4 class="font-bold text-lg">Pointcut</h4>
                            <p>Một biểu thức xác định (khớp với) các join point nơi advice nên được áp dụng. Nó giống như một truy vấn để chọn các phương thức cụ thể.</p>
                        </div>
                        <div class="bg-white p-4 rounded-lg shadow-sm">
                            <h4 class="font-bold text-lg">Target Object</h4>
                            <p>Đối tượng bean đang được tư vấn (advised) bởi một hoặc nhiều aspect. Còn được gọi là "advised object".</p>
                        </div>
                         <div class="bg-white p-4 rounded-lg shadow-sm">
                            <h4 class="font-bold text-lg">AOP Proxy</h4>
                            <p>Spring tạo một đối tượng proxy để bao bọc đối tượng target. Proxy này được sử dụng để thực thi các advice. Spring AOP sử dụng proxy động JDK (nếu target object triển khai interface) hoặc proxy CGLIB (nếu không).</p>
                        </div>
                    </div>
                `
            },
            'advice-types': {
                title: 'Các loại Advice',
                content: `
                    <h3>Các loại Advice và Thứ tự thực thi</h3>
                    <p>Spring AOP cung cấp năm loại advice chính. Hiểu rõ thời điểm mỗi loại được thực thi là rất quan trọng.</p>
                    <div id="aop-advice-diagram" class="my-8 p-6 bg-white rounded-lg shadow-lg text-center">
                        <div class="font-bold text-xl mb-4">Luồng thực thi Advice</div>
                        <div class="relative flex flex-col items-center space-y-2">
                            <div data-advice="around-before" class="aop-advice-step p-3 bg-purple-100 border-2 border-purple-400 rounded-full w-full max-w-md cursor-pointer transition-all duration-300">@Around (trước)</div>
                            <div data-advice="before" class="aop-advice-step p-3 bg-blue-100 border-2 border-blue-400 rounded-full w-full max-w-sm cursor-pointer transition-all duration-300">@Before</div>
                            <div class="p-4 bg-green-200 border-2 border-green-500 rounded-lg w-full max-w-xs font-bold">Thực thi phương thức mục tiêu</div>
                            <div data-advice="after-returning" class="aop-advice-step p-3 bg-green-100 border-2 border-green-400 rounded-full w-full max-w-sm cursor-pointer transition-all duration-300">@AfterReturning (nếu thành công)</div>
                            <div data-advice="after-throwing" class="aop-advice-step p-3 bg-red-100 border-2 border-red-400 rounded-full w-full max-w-sm cursor-pointer transition-all duration-300">@AfterThrowing (nếu có lỗi)</div>
                             <div data-advice="after" class="aop-advice-step p-3 bg-yellow-100 border-2 border-yellow-400 rounded-full w-full max-w-sm cursor-pointer transition-all duration-300">@After (luôn luôn)</div>
                            <div data-advice="around-after" class="aop-advice-step p-3 bg-purple-100 border-2 border-purple-400 rounded-full w-full max-w-md cursor-pointer transition-all duration-300">@Around (sau)</div>
                        </div>
                    </div>
                    <div id="aop-advice-details" class="p-4 bg-gray-50 rounded-md border min-h-[50px]">
                        <p class="text-gray-500">Hover vào một bước trong sơ đồ để xem mô tả.</p>
                    </div>
                `
            },
             'pointcuts': {
                title: 'Biểu thức Pointcut',
                content: `
                    <h3>Biểu thức Pointcut</h3>
                    <p>Biểu thức Pointcut sử dụng ngôn ngữ của AspectJ để chọn các join point. Chúng là chìa khóa để áp dụng advice một cách chính xác.</p>
                     <h4 class="text-xl font-semibold mt-6 mb-2">Các Designator phổ biến</h4>
                     <ul class="list-disc list-inside space-y-4">
                        <li>
                            <strong><code>execution</code>:</strong> Phổ biến nhất, khớp với việc thực thi phương thức.
                            <div class="code-block"><pre><code>execution(public * com.example.service.*.*(..))</code></pre></div>
                            <p class="text-sm text-stone-500 -mt-2 ml-4">Khớp với bất kỳ phương thức public nào trong bất kỳ lớp nào của gói <code>com.example.service</code>.</p>
                        </li>
                        <li>
                            <strong><code>within</code>:</strong> Giới hạn khớp với các join point trong các kiểu (lớp hoặc interface) nhất định.
                             <div class="code-block"><pre><code>within(com.example.service..*)</code></pre></div>
                             <p class="text-sm text-stone-500 -mt-2 ml-4">Khớp với tất cả các phương thức trong gói <code>com.example.service</code> và các gói con của nó.</p>
                        </li>
                         <li>
                            <strong><code>@annotation</code>:</strong> Khớp với các join point nơi phương thức thực thi có một annotation nhất định.
                            <div class="code-block"><pre><code>@annotation(com.example.security.Auditable)</code></pre></div>
                            <p class="text-sm text-stone-500 -mt-2 ml-4">Khớp với bất kỳ phương thức nào được chú thích bằng <code>@Auditable</code>.</p>
                        </li>
                         <li>
                            <strong><code>bean</code>:</strong> Khớp với các phương thức của một Spring bean có tên cụ thể.
                            <div class="code-block"><pre><code>bean(*Service)</code></pre></div>
                            <p class="text-sm text-stone-500 -mt-2 ml-4">Khớp với tất cả các bean có tên kết thúc bằng "Service".</p>
                        </li>
                     </ul>
                     <p class="mt-4">Bạn có thể kết hợp các biểu thức này bằng cách sử dụng <code>&&</code> (AND), <code>||</code> (OR), và <code>!</code> (NOT).</p>
                `
            }
        }
    },
    'data': {
        title: 'III. Truy cập dữ liệu',
        subtopics: {
            'jpa': {
                title: 'Spring Data JPA',
                content: `
                    <h3>Spring Data JPA</h3>
                    <p>Spring Data JPA đơn giản hóa đáng kể việc triển khai tầng truy cập dữ liệu dựa trên JPA. Nó cung cấp một abstraction mạnh mẽ trên các repository, giảm thiểu mã boilerplate.</p>
                    <h4 class="text-xl font-semibold mt-6 mb-2">1. Interfaces Repository</h4>
                    <p>Chỉ cần định nghĩa một interface kế thừa từ <code>JpaRepository</code>, Spring Data sẽ tự động cung cấp các triển khai cho các thao tác CRUD cơ bản.</p>
                    <div class="code-block"><pre><code>public interface UserRepository extends JpaRepository&lt;User, Long&gt; {
    // Spring Data sẽ tự động triển khai các phương thức CRUD
}</code></pre></div>

                    <h4 class="text-xl font-semibold mt-6 mb-2">2. Query Methods</h4>
                    <p>Spring Data có thể tự động tạo các truy vấn từ tên phương thức trong interface repository. Đây là một ví dụ về "convention over configuration".</p>
                     <div class="code-block"><pre><code>public interface UserRepository extends JpaRepository&lt;User, Long&gt; {
    // Dịch thành: SELECT u FROM User u WHERE u.emailAddress = ?1
    User findByEmailAddress(String emailAddress);

    // Dịch thành: SELECT u FROM User u WHERE u.lastname = ?1 ORDER BY u.firstname ASC
    List&lt;User&gt; findByLastnameOrderByFirstnameAsc(String lastname);
}</code></pre></div>

                    <h4 class="text-xl font-semibold mt-6 mb-2">3. @Query Annotation</h4>
                    <p>Đối với các truy vấn phức tạp không thể biểu diễn qua tên phương thức, bạn có thể sử dụng annotation <code>@Query</code> để viết JPQL hoặc SQL gốc.</p>
                    <div class="code-block"><pre><code>public interface UserRepository extends JpaRepository&lt;User, Long&gt; {
    @Query("SELECT u FROM User u WHERE u.status = ?1")
    List&lt;User&gt; findUsersByStatus(Integer status);

    @Query(value = "SELECT * FROM users WHERE email_address = :email", nativeQuery = true)
    User findUserByEmailNative(@Param("email") String email);
}</code></pre></div>
                `
            },
            'tx': {
                title: 'Quản lý Giao dịch',
                content: `
                    <h3>Quản lý Giao dịch với @Transactional</h3>
                    <p>Spring cung cấp một mô hình quản lý giao dịch khai báo mạnh mẽ thông qua annotation <code>@Transactional</code>. Điều này giúp tách biệt logic quản lý giao dịch khỏi logic nghiệp vụ.</p>
                    <div class="code-block"><pre><code>@Service
public class UserManagementService {
    @Autowired
    private UserRepository userRepository;

    @Transactional
    public void registerUser(User user) {
        // Tất cả các thao tác trong phương thức này
        // sẽ được thực thi trong một giao dịch duy nhất.
        // Giao dịch sẽ commit khi phương thức kết thúc,
        // hoặc rollback nếu có RuntimeException.
        userRepository.save(user);
    }
}</code></pre></div>
                    <h4 class="text-xl font-semibold mt-6 mb-2">Hành vi Lan truyền (Propagation)</h4>
                    <p>Xác định cách một phương thức <code>@Transactional</code> tương tác với một giao dịch hiện có.</p>
                    <ul class="list-disc list-inside space-y-2">
                        <li><strong>REQUIRED (Mặc định):</strong> Tham gia giao dịch hiện có; tạo một giao dịch mới nếu không có.</li>
                        <li><strong>REQUIRES_NEW:</strong> Luôn tạo một giao dịch mới, tạm dừng giao dịch hiện tại (nếu có).</li>
                        <li><strong>SUPPORTS:</strong> Chạy trong một giao dịch nếu có; nếu không, chạy không có giao dịch.</li>
                        <li><strong>NOT_SUPPORTED:</strong> Luôn chạy không có giao dịch, tạm dừng giao dịch hiện tại (nếu có).</li>
                        <li><strong>MANDATORY:</strong> Phải có một giao dịch hiện có, nếu không sẽ ném ngoại lệ.</li>
                        <li><strong>NEVER:</strong> Không được chạy trong một giao dịch, nếu có sẽ ném ngoại lệ.</li>
                        <li><strong>NESTED:</strong> Tạo một giao dịch lồng nhau (sử dụng savepoint của JDBC) nếu có giao dịch hiện tại; hoạt động như REQUIRED nếu không.</li>
                    </ul>

                     <h4 class="text-xl font-semibold mt-6 mb-2">Mức độ Cô lập (Isolation)</h4>
                    <p>Xác định mức độ một giao dịch được bảo vệ khỏi sự can thiệp của các giao dịch khác.</p>
                    <ul class="list-disc list-inside space-y-2">
                        <li><strong>READ_UNCOMMITTED:</strong> Có thể đọc dữ liệu chưa được commit (dirty read).</li>
                        <li><strong>READ_COMMITTED:</strong> Ngăn dirty read. Đây là mức mặc định của hầu hết các cơ sở dữ liệu.</li>
                        <li><strong>REPEATABLE_READ:</strong> Ngăn dirty read và non-repeatable read.</li>
                        <li><strong>SERIALIZABLE:</strong> Mức độ cao nhất, ngăn tất cả các vấn đề về đồng thời nhưng ảnh hưởng đến hiệu năng.</li>
                    </ul>
                `
            }
        }
    },
    'mvc': {
        title: 'IV. Spring MVC',
        subtopics: {
            'dispatcher': {
                title: 'DispatcherServlet',
                content: `
                    <h3>Kiến trúc Spring MVC: Vai trò của DispatcherServlet</h3>
                    <p><code>DispatcherServlet</code> là cốt lõi của Spring MVC. Nó hoạt động như một "Front Controller", nhận tất cả các yêu cầu HTTP đến và điều phối chúng đến các thành phần phù hợp để xử lý.</p>
                    <h4 class="text-xl font-semibold mt-6 mb-2">Luồng xử lý yêu cầu</h4>
                    <ol class="list-decimal list-inside space-y-2">
                        <li>Yêu cầu HTTP đến <code>DispatcherServlet</code>.</li>
                        <li><code>DispatcherServlet</code> tham khảo <code>HandlerMapping</code> để tìm một controller (handler) phù hợp.</li>
                        <li><code>DispatcherServlet</code> gọi handler thông qua một <code>HandlerAdapter</code> thích hợp.</li>
                        <li>Handler thực thi logic, xử lý yêu cầu và trả về một đối tượng <code>ModelAndView</code> (chứa dữ liệu model và tên view logic).</li>
                        <li><code>DispatcherServlet</code> tham khảo <code>ViewResolver</code> để ánh xạ tên view logic thành một <code>View</code> cụ thể (ví dụ: một trang JSP).</li>
                        <li><code>DispatcherServlet</code> render view bằng cách truyền dữ liệu model vào đó.</li>
                        <li>Phản hồi HTTP được gửi lại cho client.</li>
                    </ol>
                    <div class="note">
                        <p>Kiến trúc này giúp tách biệt rõ ràng các mối quan tâm: controller xử lý logic, view xử lý hiển thị, và model mang dữ liệu. <code>DispatcherServlet</code> điều phối tất cả, làm cho ứng dụng có cấu trúc và dễ bảo trì.</p>
                    </div>
                `
            },
            'controllers': {
                title: 'Controllers & Mapping',
                content: `
                    <h3>Controllers và Request Mapping</h3>
                    <p>Controllers là các lớp chịu trách nhiệm xử lý yêu cầu của người dùng. Các annotation Request Mapping được sử dụng để liên kết các URL và phương thức HTTP với các phương thức controller cụ thể.</p>
                    
                    <h4 class="text-xl font-semibold mt-6 mb-2"><code>@RequestMapping</code> và các phím tắt</h4>
                    <p><code>@RequestMapping</code> là annotation chung. Tuy nhiên, để mã nguồn rõ ràng hơn, nên sử dụng các annotation chuyên biệt cho từng phương thức HTTP:</p>
                     <ul class="list-disc list-inside space-y-2">
                        <li><strong><code>@GetMapping</code>:</strong> Xử lý các yêu cầu HTTP GET.</li>
                        <li><strong><code>@PostMapping</code>:</strong> Xử lý các yêu cầu HTTP POST.</li>
                        <li><strong><code>@PutMapping</code>:</strong> Xử lý các yêu cầu HTTP PUT.</li>
                        <li><strong><code>@DeleteMapping</code>:</strong> Xử lý các yêu cầu HTTP DELETE.</li>
                        <li><strong><code>@PatchMapping</code>:</strong> Xử lý các yêu cầu HTTP PATCH.</li>
                    </ul>
                    
                     <div class="code-block"><pre><code>@Controller
@RequestMapping("/users")
public class UserController {

    @GetMapping("/{id}")
    public String getUser(@PathVariable Long id, Model model) {
        // ... logic để lấy user
        model.addAttribute("user", userService.findById(id));
        return "userProfile"; // Trả về tên view
    }

    @PostMapping
    public String createUser(User user) {
        // ... logic để tạo user
        return "redirect:/users"; // Chuyển hướng sau khi tạo
    }
}</code></pre></div>
                `
            }
        }
    },
     'rest': {
        title: 'V. REST APIs',
        content: "Nội dung cho REST APIs"
    },
    'security': {
        title: 'VI. Spring Security',
        content: "Nội dung cho Spring Security"
    },
     'testing': {
        title: 'VII. Testing',
        content: "Nội dung cho Testing"
    },
    'boot': {
        title: 'VIII. Spring Boot',
        content: "Nội dung cho Spring Boot"
    },
    'messaging': {
        title: 'IX. Messaging',
        content: "Nội dung cho Messaging"
    }
};

const beanScopesData = [
    { 
        name: 'singleton', 
        icon: '📦',
        description: '(Mặc định) Một instance duy nhất cho mỗi container IoC. Lý tưởng cho các bean không trạng thái (stateless) được chia sẻ trên toàn ứng dụng.'
    },
    { 
        name: 'prototype', 
        icon: '✨',
        description: 'Một instance mới được tạo mỗi khi được yêu cầu. Dùng cho các bean có trạng thái (stateful). Spring không quản lý toàn bộ vòng đời của bean prototype sau khi tạo.'
    },
    { 
        name: 'request', 
        icon: '🌐',
        description: 'Một instance mới cho mỗi yêu cầu HTTP. Chỉ hợp lệ trong ứng dụng web. Đảm bảo dữ liệu không bị chia sẻ giữa các yêu cầu.'
    },
    { 
        name: 'session', 
        icon: '👤',
        description: 'Một instance mới cho mỗi phiên HTTP. Dùng để lưu trữ dữ liệu cụ thể của người dùng qua nhiều yêu cầu. Chỉ hợp lệ trong ứng dụng web.'
    },
    { 
        name: 'application', 
        icon: '🏢',
        description: 'Một instance duy nhất cho vòng đời của ServletContext. Tương tự singleton nhưng trong phạm vi toàn bộ ứng dụng web. Chỉ hợp lệ trong ứng dụng web.'
    }
];

const aopAdviceDetailsData = {
    'around-before': { title: '@Around (trước)', text: 'Advice mạnh mẽ nhất. Thực thi trước khi join point được gọi. Có thể quyết định có tiếp tục thực thi join point hay không bằng cách gọi `proceedingJoinPoint.proceed()`.' },
    'before': { title: '@Before', text: 'Thực thi trước khi join point được gọi. Không thể ngăn chặn việc thực thi join point (trừ khi ném ra một ngoại lệ).' },
    'after-returning': { title: '@AfterReturning', text: 'Thực thi sau khi join point hoàn thành thành công và trả về một giá trị. Có thể truy cập giá trị trả về.' },
    'after-throwing': { title: '@AfterThrowing', text: 'Thực thi nếu một join point ném ra một ngoại lệ. Có thể truy cập ngoại lệ được ném ra.' },
    'after': { title: '@After (finally)', text: 'Thực thi sau khi join point kết thúc, bất kể nó trả về giá trị hay ném ra ngoại lệ. Tương tự như khối `finally`.' },
    'around-after': { title: '@Around (sau)', text: 'Thực thi sau khi join point đã hoàn tất (sau khi `proceed()` được gọi). Có thể sửa đổi giá trị trả về.' }
};

document.addEventListener('DOMContentLoaded', () => {
    const mainNav = document.getElementById('main-nav');
    const contentContainer = document.getElementById('content-container');
    const menuToggle = document.getElementById('menu-toggle');
    const sidebar = document.getElementById('sidebar');

    const mainTopics = [
        { id: 'container', title: 'I. Container & IoC' },
        { id: 'aop', title: 'II. AOP' },
        { id: 'data', title: 'III. Truy cập dữ liệu' },
        { id: 'mvc', title: 'IV. Spring MVC' },
        { id: 'rest', title: 'V. REST APIs' },
        { id: 'security', title: 'VI. Spring Security' },
        { id: 'testing', title: 'VII. Testing' },
        { id: 'boot', title: 'VIII. Spring Boot' },
        { id: 'messaging', title: 'IX. Messaging' },
    ];

    mainTopics.forEach(topic => {
        const link = document.createElement('a');
        link.href = '#';
        link.textContent = topic.title;
        link.dataset.topic = topic.id;
        link.className = 'block main-nav-item py-2.5 px-4 rounded transition duration-200 hover:bg-white hover:text-stone-900';
        mainNav.appendChild(link);
    });

    const renderContent = (topicId, subtopicId = null) => {
        const topic = contentData[topicId];
        if (!topic) {
            contentContainer.innerHTML = contentData['intro'].content;
            return;
        }

        let html = ``;
        if (topic.subtopics) {
            const subtopicKeys = Object.keys(topic.subtopics);
            const activeSubtopicId = subtopicId || subtopicKeys[0];
            
            html += `<nav class="flex border-b border-stone-300 mb-6">`;
            subtopicKeys.forEach(key => {
                html += `<button data-topic="${topicId}" data-subtopic="${key}" class="sub-nav-item py-3 px-4 sm:px-6 text-sm sm:text-base font-medium text-stone-500 border-b-2 border-transparent hover:border-stone-400 hover:text-stone-700 transition-colors duration-200 ${key === activeSubtopicId ? 'active' : ''}">${topic.subtopics[key].title}</button>`;
            });
            html += `</nav>`;
            html += `<div class="main-content">${topic.subtopics[activeSubtopicId].content}</div>`;
        } else {
             html += `<div class="main-content"><h2>${topic.title}</h2>${topic.content}</div>`;
        }
        
        contentContainer.innerHTML = html;
        addCodeCopyButtons();
        
        // Post-render initializations
        if(topicId === 'container' && (subtopicId === 'di' || !subtopicId)) {
             initializeDIChart();
        }
        if(topicId === 'container' && (subtopicId === 'bean-scope' || !subtopicId)) {
             initializeBeanScopes();
        }
        if(topicId === 'aop' && (subtopicId === 'advice-types')) {
            initializeAOPDiagram();
        }
    };

    mainNav.addEventListener('click', (e) => {
        e.preventDefault();
        if (e.target.matches('.main-nav-item')) {
            const topicId = e.target.dataset.topic;
            
            document.querySelectorAll('.main-nav-item').forEach(item => item.classList.remove('active'));
            e.target.classList.add('active');
            
            renderContent(topicId);
             if (window.innerWidth < 768) {
                sidebar.classList.add('-translate-x-full');
            }
        }
    });

    contentContainer.addEventListener('click', e => {
        if(e.target.matches('.sub-nav-item')) {
            const topicId = e.target.dataset.topic;
            const subtopicId = e.target.dataset.subtopic;
            renderContent(topicId, subtopicId);
        }
    });

    menuToggle.addEventListener('click', () => {
        sidebar.classList.toggle('-translate-x-full');
    });
    
    // Initial load
    document.querySelector('.main-nav-item').classList.add('active');
    renderContent('container');
});

function addCodeCopyButtons() {
    document.querySelectorAll('.code-block').forEach(block => {
        const button = document.createElement('button');
        button.textContent = 'Sao chép';
        button.className = 'copy-btn';
        block.appendChild(button);

        button.addEventListener('click', () => {
            const code = block.querySelector('pre code').innerText;
            navigator.clipboard.writeText(code).then(() => {
                button.textContent = 'Đã chép!';
                setTimeout(() => {
                    button.textContent = 'Sao chép';
                }, 2000);
            });
        });
    });
}

function initializeDIChart() {
    const ctx = document.getElementById('diComparisonChart');
    if(ctx) {
        new Chart(ctx, {
            type: 'bar',
            data: {
                labels: ['Constructor Injection', 'Setter Injection', 'Field Injection'],
                datasets: [{
                    label: 'Khả năng kiểm thử',
                    data: [10, 7, 3],
                    backgroundColor: 'rgba(59, 130, 246, 0.7)',
                    borderColor: 'rgba(59, 130, 246, 1)',
                    borderWidth: 1
                }, {
                    label: 'Tính bất biến',
                    data: [10, 2, 2],
                    backgroundColor: 'rgba(16, 185, 129, 0.7)',
                    borderColor: 'rgba(16, 185, 129, 1)',
                    borderWidth: 1
                }, {
                    label: 'Độ ngắn gọn',
                    data: [6, 4, 10],
                     backgroundColor: 'rgba(239, 68, 68, 0.7)',
                    borderColor: 'rgba(239, 68, 68, 1)',
                    borderWidth: 1
                }]
            },
            options: {
                indexAxis: 'y',
                maintainAspectRatio: false,
                scales: {
                    x: {
                        beginAtZero: true,
                        max: 10,
                        title: { display: true, text: 'Đánh giá (trên 10)' }
                    }
                },
                plugins: {
                    title: {
                        display: true,
                        text: 'So sánh các loại Dependency Injection'
                    },
                    tooltip: {
                        callbacks: {
                            label: function(context) {
                                let label = context.dataset.label || '';
                                if (label) {
                                    label += ': ';
                                }
                                if (context.parsed.x !== null) {
                                    label += context.parsed.x + '/10';
                                }
                                return label;
                            }
                        }
                    }
                }
            }
        });
    }
}

function initializeBeanScopes() {
    const container = document.getElementById('bean-scopes-container');
    const detailsPanel = document.getElementById('bean-scope-details');
    if (!container || !detailsPanel) return;
    
    container.innerHTML = beanScopesData.map(scope => `
        <div data-scope-name="${scope.name}" class="scope-card bg-white p-4 rounded-lg shadow-sm cursor-pointer hover:shadow-md hover:-translate-y-1 transition-all duration-300">
            <div class="flex items-center">
                <span class="text-3xl mr-4">${scope.icon}</span>
                <div>
                    <h4 class="font-bold text-lg capitalize">${scope.name}</h4>
                    <p class="text-sm text-stone-500">${scope.description.split('.')[0]}.</p>
                </div>
            </div>
        </div>
    `).join('');
    
    container.addEventListener('click', e => {
        const card = e.target.closest('.scope-card');
        if (card) {
            document.querySelectorAll('.scope-card').forEach(c => c.classList.remove('ring-2', 'ring-blue-500'));
            card.classList.add('ring-2', 'ring-blue-500');

            const scopeName = card.dataset.scopeName;
            const scopeData = beanScopesData.find(s => s.name === scopeName);
            if (scopeData) {
                detailsPanel.innerHTML = `
                    <h4 class="font-bold text-xl capitalize">${scopeData.name}</h4>
                    <p class="mt-2">${scopeData.description}</p>
                `;
                detailsPanel.classList.remove('hidden');
            }
        }
    });
}

function initializeAOPDiagram() {
    const diagram = document.getElementById('aop-advice-diagram');
    const detailsPanel = document.getElementById('aop-advice-details');
    if(!diagram || !detailsPanel) return;

    diagram.querySelectorAll('.aop-advice-step').forEach(step => {
        step.addEventListener('mouseenter', () => {
            const adviceKey = step.dataset.advice;
            const adviceData = aopAdviceDetailsData[adviceKey];
            if (adviceData) {
                detailsPanel.innerHTML = `<h5 class="font-semibold">${adviceData.title}</h5><p>${adviceData.text}</p>`;
                step.classList.add('scale-105', 'shadow-xl', 'z-10');
            }
        });
        step.addEventListener('mouseleave', () => {
            step.classList.remove('scale-105', 'shadow-xl', 'z-10');
            detailsPanel.innerHTML = `<p class="text-gray-500">Hover vào một bước trong sơ đồ để xem mô tả.</p>`;
        });
    });
}
</script>
</body>
</html>
