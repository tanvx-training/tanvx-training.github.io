<!DOCTYPE html>
<html lang="vi" class="scroll-smooth">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Cẩm Nang Spring Framework Tương Tác</title>
    <!-- Chosen Palette: Warm Neutrals -->
    <!-- Application Structure Plan: A two-column layout is used. The left sidebar contains thematic navigation (Core, AOP, Data, Spring Boot, Spring MVC, Spring Security, Spring Test) with a list of questions under each, allowing users to jump to specific topics. The right pane displays the content. A search bar filters the navigation for for quick access. This structure transforms the linear Q&A document into an explorable knowledge base, which is more user-friendly for reference and learning, as it provides a constant map of the content and prevents the user from getting lost in a long page. -->
    <!-- Visualization & Content Choices: Content is organized into Q&A sections. Key concepts like the 'Bean Lifecycle' are visualized using a styled HTML/CSS diagram for better comprehension (Goal: Organize/Inform). Side-by-side comparisons (e.g., 'Proxy Types') use a two-column grid (Goal: Compare). Code blocks have a 'copy' button for utility (Goal: Utility). All interactions are handled by vanilla JS. -->
    <!-- CONFIRMATION: NO SVG graphics used. NO Mermaid JS used. -->
    <script src="https://cdn.tailwindcss.com"></script>
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700&display=swap" rel="stylesheet">
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.0/css/all.min.css">
    <style>
        body {
            font-family: 'Inter', sans-serif;
            background-color: #fdfcfb;
            color: #333;
        }
        ::-webkit-scrollbar {
            width: 8px;
        }
        ::-webkit-scrollbar-track {
            background: #f1f1f1;
        }
        ::-webkit-scrollbar-thumb {
            background: #c5c5c5;
            border-radius: 10px;
        }
        ::-webkit-scrollbar-thumb:hover {
            background: #a0a0a0;
        }
        .code-block {
            background-color: #2d3748;
            color: #e2e8f0;
            border-radius: 0.5rem;
            padding: 1rem;
            position: relative;
            overflow-x: auto;
        }
        .copy-btn {
            position: absolute;
            top: 0.5rem;
            right: 0.5rem;
            background-color: #4a5568;
            color: #e2e8f0;
            border: none;
            padding: 0.25rem 0.5rem;
            border-radius: 0.25rem;
            cursor: pointer;
            font-size: 0.8rem;
            opacity: 0.7;
            transition: opacity 0.2s;
        }
        .code-block:hover .copy-btn {
            opacity: 1;
        }
        .nav-link.active {
            background-color: #fbeedb;
            color: #c28217;
            font-weight: 600;
        }
        .lifecycle-step {
            border: 1px solid #e2e8f0;
            padding: 1rem;
            border-radius: 0.5rem;
            background-color: #ffffff;
            text-align: center;
            box-shadow: 0 1px 3px 0 rgba(0, 0, 0, 0.1), 0 1px 2px 0 rgba(0, 0, 0, 0.06);
        }
        .lifecycle-arrow {
            display: flex;
            align-items: center;
            justify-content: center;
            color: #9ca3af;
        }
    </style>
</head>
<body class="bg-amber-50 text-gray-800">

<div class="flex flex-col md:flex-row">
    <!-- Sidebar -->
    <aside id="sidebar" class="w-full md:w-80 lg:w-96 bg-white/80 backdrop-blur-sm border-r border-gray-200/80 p-6 md:h-screen md:sticky top-0 transition-transform -translate-x-full md:translate-x-0 z-20">
        <button id="close-sidebar-btn" class="md:hidden absolute top-4 right-4 text-gray-600">
            <i class="fas fa-times text-xl"></i>
        </button>
        <h1 class="text-2xl font-bold text-amber-900 mb-2">Cẩm Nang Spring</h1>
        <p class="text-sm text-gray-500 mb-6">Khám phá các khái niệm Spring Framework một cách tương tác.</p>
        <div class="relative mb-6">
            <input type="text" id="search-box" placeholder="Tìm kiếm câu hỏi..." class="w-full pl-10 pr-4 py-2 border border-gray-300 rounded-lg focus:ring-2 focus:ring-amber-500 focus:border-amber-500 transition">
            <i class="fas fa-search absolute left-3 top-1/2 -translate-y-1/2 text-gray-400"></i>
        </div>
        <nav id="navigation" class="space-y-6 overflow-y-auto" style="height: calc(100vh - 160px);"></nav>
    </aside>

    <!-- Main Content -->
    <main class="w-full p-6 md:p-10 lg:p-12">
        <button id="open-sidebar-btn" class="md:hidden fixed top-4 left-4 z-10 bg-white p-2 rounded-md shadow-md">
            <i class="fas fa-bars text-xl text-gray-700"></i>
        </button>
        <div class="max-w-4xl mx-auto">
            <header class="mb-12">
                <h1 class="text-4xl md:text-5xl font-bold text-amber-900 mb-4">Cẩm Nang Spring Framework Tương Tác</h1>
                <p class="text-lg text-gray-600">Chào mừng bạn đến với cẩm nang tương tác về Spring Framework. Trang này được thiết kế để giúp bạn dễ dàng khám phá và hiểu sâu các khái niệm cốt lõi, từ Dependency Injection đến Quản lý Dữ liệu và AOP. Sử dụng thanh điều hướng bên trái để chuyển qua các chủ đề chính hoặc tìm kiếm để có câu trả lời nhanh chóng.</p>
            </header>
            <div id="content-container" class="space-y-16"></div>
        </div>
    </main>
</div>

<script>
    // Declare app, db, and auth globally or within a scope accessible to all functions that need them.
    let app;
    let db;
    let auth;

    const data = [
        // =================================================================
        // Khái niệm Cốt lõi
        // =================================================================
        {
            category: "Khái niệm Cốt lõi",
            id: "di-definition",
            question: "Dependency Injection là gì và ưu điểm của nó là gì?",
            content: `
                    <p class="mb-4"><strong>Dependency Injection (DI)</strong> là một kỹ thuật lập trình phần mềm trong đó các đối tượng không tự tạo ra các dependency (sự phụ thuộc) của chúng. Thay vào đó, các đối tượng khai báo các dependency mà chúng cần, và một đối tượng bên ngoài hoặc một framework sẽ có nhiệm vụ cung cấp các dependency cụ thể cho các đối tượng đó.</p>
                    <h4 class="font-semibold text-lg mb-2">Các loại Dependency Injection:</h4>
                    <ul class="list-disc list-inside mb-4 space-y-1">
                        <li>Constructor injection</li>
                        <li>Setter injection</li>
                        <li>Interface injection</li>
                    </ul>
                    <h4 class="font-semibold text-lg mb-2">Ưu điểm của việc sử dụng Dependency Injection:</h4>
                    <ul class="list-disc list-inside mb-4 space-y-1">
                        <li>Tăng khả năng tái sử dụng mã nguồn</li>
                        <li>Tăng khả năng đọc hiểu mã nguồn</li>
                        <li>Tăng khả năng bảo trì mã nguồn</li>
                        <li>Tăng khả năng kiểm thử (testability) của mã nguồn</li>
                        <li>Giảm sự kết dính (coupling)</li>
                        <li>Tăng sự gắn kết (cohesion)</li>
                    </ul>
                `
        },
        {
            category: "Khái niệm Cốt lõi",
            id: "container-lifecycle",
            question: "Khái niệm 'container' là gì và vòng đời của nó như thế nào?",
            content: `
                    <p class="mb-4"><strong>Container</strong> là một môi trường thực thi cung cấp các dịch vụ kỹ thuật bổ sung cho mã nguồn của bạn sử dụng. Thông thường, các container sử dụng kỹ thuật IoC (Inversion of Control), cho phép bạn tập trung vào việc tạo ra khía cạnh nghiệp vụ của mã nguồn. Spring cung cấp một container cho các bean, quản lý vòng đời của chúng và cung cấp các dịch vụ bổ sung thông qua <code>ApplicationContext</code>.</p>
                    <h4 class="font-semibold text-lg mb-4">Vòng đời của Spring Container:</h4>
                    <ol class="list-decimal list-inside space-y-2">
                        <li>Ứng dụng được khởi động.</li>
                        <li>Spring container được tạo ra.</li>
                        <li>Container đọc cấu hình.</li>
                        <li>Các định nghĩa bean (bean definitions) được tạo ra từ cấu hình.</li>
                        <li>Các <code>BeanFactoryPostProcessor</code> xử lý các định nghĩa bean.</li>
                        <li>Các instance của Spring bean được tạo ra.</li>
                        <li>Các Spring bean được cấu hình và lắp ráp.</li>
                        <li>Các <code>BeanPostProcessor</code> được gọi.</li>
                        <li>Ứng dụng chạy.</li>
                        <li>Ứng dụng bị tắt, Spring Context được đóng lại.</li>
                        <li>Các callback hủy (destruction callbacks) được gọi.</li>
                    </ol>
                `
        },
        {
            category: "Khái niệm Cốt lõi",
            id: "bean-lifecycle",
            question: "Bạn có thể mô tả vòng đời của một Spring Bean trong ApplicationContext không?",
            content: `
                    <p class="mb-6">Vòng đời của một bean mô tả các giai đoạn mà bean trải qua từ khi được khởi tạo cho đến khi bị hủy. Đây là một quy trình có trật tự rõ ràng, được quản lý bởi Spring Container để cung cấp các điểm can thiệp cho logic tùy chỉnh.</p>
                    <div class="space-y-2">
                        <div class="lifecycle-step bg-green-50 border-green-200">
                            <span class="font-bold text-green-800">1. Khởi tạo Instance</span>
                            <p class="text-sm text-gray-600">Spring tạo đối tượng bean bằng constructor.</p>
                        </div>
                        <div class="lifecycle-arrow"><i class="fas fa-arrow-down"></i></div>
                        <div class="lifecycle-step bg-blue-50 border-blue-200">
                            <span class="font-bold text-blue-800">2. Tiêm Dependency</span>
                            <p class="text-sm text-gray-600">Các thuộc tính và phụ thuộc được tiêm vào (DI).</p>
                        </div>
                        <div class="lifecycle-arrow"><i class="fas fa-arrow-down"></i></div>
                        <div class="lifecycle-step bg-purple-50 border-purple-200">
                            <span class="font-bold text-purple-800">3. BeanPostProcessor (Trước Init)</span>
                            <p class="text-sm text-gray-600"><code>postProcessBeforeInitialization</code> được gọi.</p>
                        </div>
                        <div class="lifecycle-arrow"><i class="fas fa-arrow-down"></i></div>
                        <div class="lifecycle-step bg-yellow-50 border-yellow-200">
                            <span class="font-bold text-yellow-800">4. Phương thức Init</span>
                            <p class="text-sm text-gray-600"><code>@PostConstruct</code>, <code>afterPropertiesSet</code>, và <code>init-method</code> tùy chỉnh được gọi theo thứ tự.</p>
                        </div>
                        <div class="lifecycle-arrow"><i class="fas fa-arrow-down"></i></div>
                        <div class="lifecycle-step bg-purple-50 border-purple-200">
                            <span class="font-bold text-purple-800">5. BeanPostProcessor (Sau Init)</span>
                            <p class="text-sm text-gray-600"><code>postProcessAfterInitialization</code> được gọi. Bean bây giờ đã sẵn sàng.</p>
                        </div>
                        <div class="lifecycle-arrow"><i class="fas fa-ellipsis-v mx-auto my-2 text-2xl"></i></div>
                        <div class="lifecycle-step bg-red-50 border-red-200">
                             <span class="font-bold text-red-800">6. Hủy Bean</span>
                            <p class="text-sm text-gray-600">Khi context đóng, các phương thức <code>@PreDestroy</code>, <code>destroy</code>, và <code>destroy-method</code> tùy chỉnh được gọi.</p>
                        </div>
                    </div>
                `
        },
        {
            category: "Khái niệm Cốt lõi",
            id: "bean-scopes",
            question: "Scopes cho Spring beans là gì? Scope mặc định là gì?",
            content: `
                    <p class="mb-4"><strong>Scope</strong> của bean định nghĩa vòng đời và khả năng hiển thị của instance. Các scope phổ biến bao gồm:</p>
                    <ul class="list-disc list-inside mb-4 space-y-2">
                        <li><strong>singleton:</strong> Chỉ một instance duy nhất cho mỗi container. <strong class="text-amber-700">Đây là scope mặc định.</strong></li>
                        <li><strong>prototype:</strong> Một instance mới mỗi khi được yêu cầu.</li>
                        <li><strong>request:</strong> Một instance mới cho mỗi HTTP request. (Chỉ dùng trong ứng dụng web)</li>
                        <li><strong>session:</strong> Một instance mới cho mỗi HTTP session. (Chỉ dùng trong ứng dụng web)</li>
                        <li><strong>application:</strong> Một instance cho mỗi <code>ServletContext</code>. (Chỉ dùng trong ứng dụng web)</li>
                    </ul>
                `
        },
        {
            category: "Khái niệm Cốt lõi",
            id: "proxy-types",
            question: "Proxy object là gì và hai loại proxy khác nhau mà Spring có thể tạo ra là gì?",
            content: `
                    <p class="mb-4">Một <strong>Proxy Object</strong> là một đối tượng thêm logic bổ sung lên trên một đối tượng đang được ủy quyền (proxied) mà không cần phải sửa đổi mã của đối tượng gốc. Spring Framework hỗ trợ hai loại proxy để triển khai các tính năng như AOP và Giao dịch.</p>
                    <div class="grid md:grid-cols-2 gap-6">
                        <div class="p-4 border rounded-lg bg-white">
                            <h4 class="font-bold text-lg text-blue-700 mb-2">1. JDK Dynamic Proxy</h4>
                            <p class="mb-2"><strong>Cách hoạt động:</strong> Tạo proxy tại thời gian chạy bằng cách implement các interface của lớp mục tiêu.</p>
                            <p class="font-semibold mb-1">Yêu cầu:</p>
                            <p class="text-sm mb-2">Lớp mục tiêu phải implement ít nhất một interface.</p>
                            <p class="font-semibold mb-1">Hạn chế:</p>
                            <p class="text-sm">Chỉ có thể proxy các lời gọi phương thức trên interface, không hỗ trợ self-invocation.</p>
                            <p class="text-xs text-gray-500 mt-2">Đây là lựa chọn mặc định của Spring.</p>
                        </div>
                        <div class="p-4 border rounded-lg bg-white">
                            <h4 class="font-bold text-lg text-green-700 mb-2">2. CGLIB Proxy</h4>
                             <p class="mb-2"><strong>Cách hoạt động:</strong> Tạo một lớp con (subclass) của lớp mục tiêu tại thời gian chạy.</p>
                            <p class="font-semibold mb-1">Yêu cầu:</p>
                            <p class="text-sm mb-2">Không yêu cầu interface.</p>
                            <p class="font-semibold mb-1">Hạn chế:</p>
                            <p class="text-sm">Không thể proxy các lớp hoặc phương thức <code>final</code>, không hỗ trợ self-invocation.</p>
                            <p class="text-xs text-gray-500 mt-2">Được sử dụng khi lớp mục tiêu không có interface.</p>
                        </div>
                    </div>
                `
        },
        // =================================================================
        // Lập trình Hướng khía cạnh (AOP)
        // =================================================================
        {
            category: "Lập trình Hướng khía cạnh (AOP)",
            id: "aop-definition",
            question: "Khái niệm về AOP là gì? Nó giải quyết vấn đề gì?",
            content: `
                    <p class="mb-4"><strong>AOP (Aspect-Oriented Programming)</strong> là một mô hình lập trình bổ sung cho Lập trình hướng đối tượng (OOP) bằng cách cung cấp một cách để tách biệt các <strong>mối quan tâm xuyên suốt (cross-cutting concerns)</strong> khỏi logic nghiệp vụ của mã nguồn. Điều này đạt được bằng khả năng thêm hành vi bổ sung vào mã nguồn mà không cần phải sửa đổi chính mã nguồn đó.</p>
                    <p class="mb-4">AOP giải quyết vấn đề của các mối quan tâm xuyên suốt, là những chức năng cần được áp dụng tại nhiều điểm trong một ứng dụng mà không làm lộn xộn logic nghiệp vụ. Ví dụ điển hình bao gồm:</p>
                    <ul class="list-disc list-inside mb-4 space-y-1">
                        <li><strong>Logging (Ghi log):</strong> Ghi lại các hoạt động của hệ thống.</li>
                        <li><strong>Security (Bảo mật):</strong> Kiểm tra quyền truy cập.</li>
                        <li><strong>Transactions (Giao dịch):</strong> Quản lý giao dịch cơ sở dữ liệu.</li>
                    </ul>
                    <p>Bằng cách sử dụng AOP, bạn có thể định nghĩa các hành vi này trong các module riêng biệt gọi là "aspect" và áp dụng chúng một cách khai báo, giúp mã nguồn sạch sẽ, dễ bảo trì và giảm trùng lặp.</p>
                `
        },
        {
            category: "Lập trình Hướng khía cạnh (AOP)",
            id: "aop-terms",
            question: "Pointcut, Join Point, Advice, Aspect, Weaving là gì?",
            content: `
                    <ul class="space-y-4">
                        <li><strong>Join Point:</strong> Một điểm trong quá trình thực thi của chương trình. Trong Spring AOP, một join point <strong>luôn là việc thực thi một phương thức</strong>.</li>
                        <li><strong>Pointcut:</strong> Một biểu thức để khớp với các join point. Nó xác định <strong>"Ở đâu"</strong> advice sẽ được áp dụng.</li>
                        <li><strong>Advice:</strong> Hành động được thực hiện bởi một aspect tại một join point cụ thể. Đây là <strong>"Cái gì"</strong> và <strong>"Khi nào"</strong> sẽ được thực thi.</li>
                        <li><strong>Aspect:</strong> Một module tập hợp <code>Pointcut</code> và <code>Advice</code> lại với nhau, đại diện cho một mối quan tâm xuyên suốt (ví dụ: một aspect cho logging).</li>
                        <li><strong>Weaving:</strong> Quá trình liên kết các aspect với các đối tượng mục tiêu để tạo ra các đối tượng được proxy. Spring AOP thực hiện <strong>Runtime Weaving</strong>.</li>
                    </ul>
                `
        },
        {
            category: "Lập trình Hướng khía cạnh (AOP)",
            id: "aop-advice-types",
            question: "Spring hỗ trợ bao nhiêu loại advice?",
            content: `
                    <p class="mb-4">Spring hỗ trợ 5 loại advice chính, mỗi loại được đại diện bởi một annotation:</p>
                    <div class="grid md:grid-cols-2 lg:grid-cols-3 gap-4">
                        <div class="p-4 border rounded-lg bg-white">
                            <h4 class="font-bold text-lg text-blue-600">@Before</h4>
                            <p class="text-sm">Thực thi <strong>trước khi</strong> join point được gọi.</p>
                        </div>
                        <div class="p-4 border rounded-lg bg-white">
                            <h4 class="font-bold text-lg text-red-600">@After</h4>
                            <p class="text-sm">Thực thi <strong>sau khi</strong> join point kết thúc (bất kể thành công hay có lỗi).</p>
                        </div>
                        <div class="p-4 border rounded-lg bg-white">
                            <h4 class="font-bold text-lg text-green-600">@AfterReturning</h4>
                            <p class="text-sm">Thực thi chỉ khi join point thực thi <strong>thành công</strong>.</p>
                        </div>
                        <div class="p-4 border rounded-lg bg-white">
                            <h4 class="font-semibold text-lg text-orange-600">@AfterThrowing</h4>
                            <p class="text-sm">Thực thi chỉ khi join point <strong>ném ra một ngoại lệ</strong>.</p>
                        </div>
                        <div class="p-4 border rounded-lg bg-white md:col-span-2 lg:col-span-1">
                            <h4 class="font-semibold text-lg text-purple-600">@Around</h4>
                            <p class="text-sm">Mạnh mẽ nhất, bao bọc xung quanh join point, cho phép kiểm soát hoàn toàn việc thực thi.</p>
                        </div>
                    </div>
                `
        },
        // =================================================================
        // Quản lý Dữ liệu
        // =================================================================
        {
            category: "Quản lý Dữ liệu",
            id: "data-exceptions",
            question: "Tại sao Spring ưu tiên unchecked exceptions và Hệ thống phân cấp Data Access Exception là gì?",
            content: `
                    <p class="mb-4">Spring ưu tiên sử dụng <strong>unchecked exceptions</strong> (kế thừa từ <code>RuntimeException</code>) cho việc truy cập dữ liệu vì chúng không buộc client phải xử lý các ngoại lệ mà họ không thể phục hồi. Điều này giúp tránh các khối <code>try-catch</code> lặp đi lặp lại và làm cho mã nguồn sạch sẽ hơn.</p>
                    <p class="mb-4">Để làm điều này, Spring cung cấp <strong>Hệ thống phân cấp Data Access Exception</strong>. Đây là một hệ thống phân cấp các <code>RuntimeException</code>. Mục đích của nó là chuyển đổi các ngoại lệ cụ thể của công nghệ (như <code>SQLException</code> từ JDBC, <code>PersistenceException</code> từ JPA) thành một bộ ngoại lệ nhất quán, độc lập với công nghệ.</p>
                    <h4 class="font-semibold text-lg mb-2">Lợi ích:</h4>
                    <ul class="list-disc list-inside mb-4 space-y-1">
                        <li><strong>Tách biệt (Decoupling):</strong> Mã nguồn của bạn không bị phụ thuộc vào các ngoại lệ của một công nghệ cụ thể.</li>
                        <li><strong>Dễ chuyển đổi:</strong> Dễ dàng chuyển từ JDBC sang JPA mà không cần thay đổi mã xử lý ngoại lệ.</li>
                    </ul>
                `
        },
        {
            category: "Quản lý Dữ liệu",
            id: "jdbc-template",
            question: "Mẫu thiết kế Template là gì và JDBC Template là gì?",
            content: `
                    <p class="mb-4"><strong>Mẫu thiết kế Template (Template Method Pattern)</strong> là một mẫu thiết kế định nghĩa bộ khung của một thuật toán trong một phương thức, và giao lại việc triển khai một số bước cụ thể cho các lớp con. Nó thúc đẩy việc tái sử dụng mã bằng cách đưa các phần chung của thuật toán vào một lớp cha.</p>
                    <p class="mb-4"><strong>JdbcTemplate</strong> là một lớp trung tâm trong Spring JDBC, áp dụng mẫu thiết kế Template để đơn giản hóa việc sử dụng JDBC. Nó xử lý tất cả các công việc lặp đi lặp lại và dễ xảy ra lỗi như:</p>
                    <ul class="list-disc list-inside mb-4 space-y-1">
                        <li>Mở và đóng kết nối, câu lệnh, và tập kết quả.</li>
                        <li>Xử lý <code>SQLException</code> và chuyển đổi chúng thành các <code>DataAccessException</code> của Spring.</li>
                    </ul>
                    <p>Việc của lập trình viên chỉ là cung cấp các phần "thay đổi" của thuật toán, chẳng hạn như câu lệnh SQL và cách ánh xạ kết quả (thông qua các callback như <code>RowMapper</code>).</p>
                `
        },
        {
            category: "Quản lý Dữ liệu",
            id: "transaction-propagation",
            question: "Transaction propagation có nghĩa là gì?",
            content: `
                    <p class="mb-4"><strong>Transaction Propagation (Sự lan truyền giao dịch)</strong> định nghĩa hành vi của một phương thức giao dịch khi nó được gọi từ bên trong một phương thức khác cũng có giao dịch. Nó xác định xem phương thức được gọi có nên tham gia vào giao dịch hiện có, tạo một giao dịch mới, hay thực thi mà không có giao dịch.</p>
                    <p class="mb-2">Các tùy chọn phổ biến trong thuộc tính <code>propagation</code> của <code>@Transactional</code> bao gồm:</p>
                    <ul class="list-disc list-inside space-y-2">
                        <li><strong>REQUIRED (mặc định):</strong> Hỗ trợ một giao dịch hiện tại, tạo một giao dịch mới nếu chưa có.</li>
                        <li><strong>REQUIRES_NEW:</strong> Luôn tạo một giao dịch mới, và tạm ngưng giao dịch hiện tại (nếu có).</li>
                        <li><strong>SUPPORTS:</strong> Hỗ trợ một giao dịch hiện tại, thực thi không có giao dịch nếu chưa có.</li>
                        <li><strong>NOT_SUPPORTED:</strong> Thực thi không có giao dịch, tạm ngưng giao dịch hiện tại (nếu có).</li>
                        <li><strong>MANDATORY:</strong> Hỗ trợ một giao dịch hiện tại, ném ra ngoại lệ nếu chưa có.</li>
                        <li><strong>NEVER:</strong> Thực thi không có giao dịch, ném ra ngoại lệ nếu có một giao dịch đang tồn tại.</li>
                        <li><strong>NESTED:</strong> Thực thi bên trong một giao dịch lồng nhau (nested transaction).</li>
                    </ul>
                `
        },
        {
            category: "Quản lý Dữ liệu",
            id: "repository-interface",
            question: "Repository interface là gì và tại sao nó là interface mà không phải là lớp?",
            content: `
                    <p class="mb-4">Trong bối cảnh của <strong>Spring Data JPA</strong>, một <strong>Repository interface</strong> là một interface mà bạn định nghĩa để khai báo các thao tác truy cập dữ liệu cho một entity cụ thể. Spring Data sau đó sẽ tự động cung cấp một implementation cho interface này tại thời điểm chạy.</p>
                    <p class="mb-4">Nó được định nghĩa là một <strong>interface</strong> vì bạn chỉ cần <strong>khai báo</strong> các phương thức bạn muốn (ví dụ: <code>findByName(String name)</code>), bạn không cần viết logic triển khai. Spring Data sẽ đảm nhận việc đó.</p>
                     <h4 class="font-semibold text-lg mb-2">Lý do sử dụng Interface:</h4>
                    <ul class="list-disc list-inside mb-4 space-y-1">
                        <li><strong>Tạo proxy tại thời điểm chạy:</strong> Spring phân tích cú pháp tên các phương thức bạn đã định nghĩa và tạo ra một đối tượng proxy triển khai các phương thức đó.</li>
                        <li><strong>Tách biệt hoàn toàn:</strong> Tách biệt "cái gì" (các thao tác bạn muốn) khỏi "cách làm" (logic truy vấn cụ thể), giúp mã nguồn sạch sẽ và tập trung vào nghiệp vụ.</li>
                        <li><strong>Giảm mã lặp:</strong> Kế thừa từ <code>JpaRepository</code> cung cấp ngay các phương thức CRUD cơ bản mà không cần viết code.</li>
                    </ul>
                `
        },
        {
            category: "Quản lý Dữ liệu",
            id: "repository-finder-methods",
            question: "Quy tắc đặt tên cho các phương thức finder trong một Repository interface là gì?",
            content: `
                    <p class="mb-4">Spring Data có một cơ chế mạnh mẽ để tự động tạo các truy vấn từ tên phương thức. Bạn chỉ cần đặt tên phương thức theo một quy ước nhất định, và Spring Data sẽ phân tích cú pháp tên đó để tạo ra câu lệnh truy vấn JPA (JPQL) tương ứng.</p>
                    <p class="mb-2"><strong>Quy tắc chung:</strong> <code>find...By[Property]...</code>, <code>read...By...</code>, <code>count...By...</code></p>
                    <h4 class="font-semibold text-lg mb-2">Ví dụ các từ khóa phổ biến:</h4>
                    <div class="code-block">
                        <button class="copy-btn"><i class="far fa-copy"></i> Copy</button>
                        <pre><code>// WHERE x.name = ?1 AND x.category = ?2
findByNameAndCategory(String name, String category)

// WHERE x.price < ?1
findByPriceLessThan(double price)

// WHERE x.description IS NULL
findByDescriptionIsNull()

// WHERE x.name LIKE ?1 (với ?1 là 'prefix%')
findByNameStartingWith(String prefix)

// WHERE x.category = ?1 ORDER BY x.price ASC
findByCategoryOrderByPriceAsc(String category)

// SELECT DISTINCT ...
findDistinctByCategory(String category)</code></pre>
                    </div>
                `
        },
        // =================================================================
        // Giới thiệu về Spring Boot
        // =================================================================
        {
            category: "Giới thiệu về Spring Boot",
            id: "springboot-what-is",
            question: "Spring Boot là gì?",
            content: `
                    <p class="mb-4"><strong>Spring Boot</strong> là một framework được xây dựng trên nền tảng của Spring Framework, giúp cho việc tạo các ứng dụng Spring độc lập (stand-alone), sẵn sàng cho môi trường sản xuất (production-grade) trở nên <strong>dễ dàng và nhanh chóng hơn</strong>.</p>
                    <p>Nó không phải là một sự thay thế cho Spring Framework mà là một cách để sử dụng Spring một cách hiệu quả hơn. Spring Boot loại bỏ phần lớn công việc cấu hình thủ công mà trước đây các nhà phát triển phải làm khi thiết lập một dự án Spring.</p>
                `
        },
        {
            category: "Giới thiệu về Spring Boot",
            id: "springboot-advantages",
            question: "Các ưu điểm của việc sử dụng Spring Boot là gì?",
            content: `
                    <p class="mb-4">Sử dụng Spring Boot mang lại rất nhiều lợi ích, giúp tăng tốc độ phát triển và đơn giản hóa việc vận hành:</p>
                    <ul class="list-disc list-inside mb-4 space-y-1">
                        <li><strong>Tự động cấu hình (Auto-configuration)</strong>: Tự động cấu hình ứng dụng của bạn dựa trên các dependency (thư viện) mà bạn thêm vào.</li>
                        <li><strong>"Opinionated" (Có chính kiến)</strong>: Cung cấp một bộ cấu hình mặc định "hợp lý" cho hầu hết các trường hợp, giúp bạn bắt đầu nhanh chóng.</li>
                        <li><strong>Starter POMs</strong>: Đơn giản hóa việc quản lý dependency trong Maven/Gradle bằng cách cung cấp các "gói" dependency đã được kiểm thử.</li>
                        <li><strong>Server nhúng (Embedded Server)</strong>: Dễ dàng đóng gói ứng dụng của bạn với một server nhúng (như Tomcat, Jetty, hoặc Undertow).</li>
                        <li><strong>Các tính năng sẵn sàng cho sản xuất (Production-ready features)</strong>: Tích hợp sẵn các tính năng như metrics, health checks, và externalized configuration.</li>
                    </ul>
                `
        },
        {
            category: "Giới thiệu về Spring Boot",
            id: "springboot-opinionated",
            question: "Tại sao nó được gọi là 'opinionated' (có chính kiến)?",
            content: `
                    <p class="mb-4">Spring Boot được gọi là "opinionated" vì nó đưa ra những <strong>"ý kiến"</strong> về cách tốt nhất để cấu hình và xây dựng một ứng dụng. Thay vì yêu cầu bạn phải đưa ra mọi quyết định cấu hình, Spring Boot sẽ tự quyết định giúp bạn dựa trên các quy ước và thực tiễn tốt nhất.</p>
                    <p>Ví dụ, nếu bạn thêm <code>spring-boot-starter-web</code> vào dự án, Spring Boot sẽ tự động cấu hình một máy chủ Tomcat nhúng, <code>DispatcherServlet</code> của Spring MVC, và các bộ chuyển đổi JSON. Tuy nhiên, bạn hoàn toàn có thể <strong>ghi đè</strong> các lựa chọn mặc định này.</p>
                `
        },
        {
            category: "Giới thiệu về Spring Boot",
            id: "springboot-auto-config-factors",
            question: "Những yếu tố nào ảnh hưởng đến những gì Spring Boot thiết lập?",
            content: `
                    <p class="mb-4">Việc tự động cấu hình của Spring Boot bị ảnh hưởng chủ yếu bởi ba yếu tố:</p>
                    <ul class="list-disc list-inside mb-4 space-y-1">
                        <li><strong>Các Starter trên Classpath</strong>: Yếu tố quan trọng nhất. Spring Boot kiểm tra các thư viện (đặc biệt là các starter) có trên classpath để quyết định cần cấu hình những gì.</li>
                        <li><strong>Cấu hình của chính bạn</strong>: Nếu bạn tự định nghĩa một bean, Spring Boot sẽ nhận ra và không tạo ra bean mặc định của nó nữa.</li>
                        <li><strong>Các thuộc tính trong <code>application.properties</code> hoặc <code>application.yml</code></strong>: Bạn có thể tùy chỉnh hành vi của các cấu hình tự động bằng cách thiết lập các thuộc tính trong các tệp cấu hình.</li>
                    </ul>
                `
        },
        {
            category: "Giới thiệu về Spring Boot",
            id: "springboot-starter-pom",
            question: "Spring Boot Starter POM là gì? Tại sao nó hữu ích?",
            content: `
                    <p class="mb-4">Một <strong>Spring Boot Starter POM</strong> (hay đơn giản là "starter") là một bộ mô tả dependency tiện lợi mà bạn có thể thêm vào dự án Maven hoặc Gradle của mình.</p>
                    <p class="mb-4"><strong>Nó hữu ích vì:</strong></p>
                    <ul class="list-disc list-inside mb-4 space-y-1">
                        <li><strong>Quản lý dependency đơn giản</strong>: Chỉ cần thêm một starter duy nhất là bạn đã có tất cả những gì cần thiết.</li>
                        <li><strong>Đảm bảo tương thích</strong>: Các starter được quản lý bởi đội ngũ Spring Boot, đảm bảo tất cả các dependency bên trong đều tương thích.</li>
                        <li><strong>Khởi đầu nhanh chóng</strong>: Cung cấp một điểm khởi đầu "một cửa" cho các công nghệ Spring và các công nghệ liên quan.</li>
                    </ul>
                    <h4 class="font-semibold text-lg mb-2">Ví dụ trong <code>pom.xml</code>:</h4>
                    <div class="code-block">
                        <button class="copy-btn"><i class="far fa-copy"></i> Copy</button>
                        <pre><code>&lt;dependency&gt;
    &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;
    &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt;
&lt;/dependency&gt;

&lt;dependency&gt;
    &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;
    &lt;artifactId&gt;spring-boot-starter-data-jpa&lt;/artifactId&gt;
&lt;/dependency&gt;</code></pre>
                    </div>
                `
        },
        {
            category: "Giới thiệu về Spring Boot",
            id: "springboot-properties-yml",
            question: "Spring Boot hỗ trợ cả tệp properties và YML. Bạn có sử dụng một trong hai không? Tại sao?",
            content: `
                    <p class="mb-4">Việc lựa chọn giữa tệp <code>.properties</code> và <code>.yml</code> (YAML) thường phụ thuộc vào sở thích cá nhân và yêu cầu của dự án, vì Spring Boot hỗ trợ cả hai một cách hoàn hảo.</p>
                    <div class="grid md:grid-cols-2 gap-6">
                        <div class="p-4 border rounded-lg bg-white">
                            <h4 class="font-bold text-lg text-blue-700 mb-2">Tệp <code>.properties</code></h4>
                            <p class="mb-2"><strong>Cú pháp:</strong> Dạng cặp <code>key=value</code> phẳng.</p>
                            <p class="font-semibold mb-1">Ưu điểm:</p>
                            <p class="text-sm mb-2">Đơn giản, dễ hiểu, được hỗ trợ rộng rãi bởi các IDE.</p>
                            <p class="font-semibold mb-1">Nhược điểm:</p>
                            <p class="text-sm">Có thể trở nên lặp lại và khó đọc khi cấu hình các thuộc tính có cấu trúc phức tạp.</p>
                        </div>
                        <div class="p-4 border rounded-lg bg-white">
                            <h4 class="font-bold text-lg text-green-700 mb-2">Tệp <code>.yml</code> (YAML)</h4>
                             <p class="mb-2"><strong>Cú pháp:</strong> Dạng cấu trúc cây, phân cấp, sử dụng thụt đầu dòng.</p>
                            <p class="font-semibold mb-1">Ưu điểm:</p>
                            <p class="text-sm mb-2">Rất ngắn gọn và dễ đọc đối với các cấu hình có cấu trúc. Hỗ trợ danh sách và các cấu trúc dữ liệu phức tạp.</p>
                            <p class="font-semibold mb-1">Nhược điểm:</p>
                            <p class="text-sm">Nhạy cảm với việc thụt đầu dòng, có thể dễ gây ra lỗi nếu không cẩn thận.</p>
                        </div>
                    </div>
                    <p class="mt-4">Nhiều nhà phát triển ưa thích <strong>YAML (<code>.yml</code>)</strong> vì nó giúp tệp cấu hình trở nên ngắn gọn và có tổ chức hơn, đặc biệt là trong các dự án lớn.</p>
                `
        },
        {
            category: "Giới thiệu về Spring Boot",
            id: "springboot-logging-control",
            question: "Bạn có thể kiểm soát việc ghi log với Spring Boot không? Bằng cách nào?",
            content: `
                    <p class="mb-4"><strong>Có.</strong> Spring Boot cung cấp khả năng kiểm soát việc ghi log một cách mạnh mẽ và linh hoạt, chủ yếu thông qua tệp <code>application.properties</code> hoặc <code>application.yml</code>.</p>
                    <h4 class="font-semibold text-lg mb-2">Cách kiểm soát:</h4>
                    <ul class="list-disc list-inside mb-4 space-y-1">
                        <li><strong>Thiết lập cấp độ log (Log Levels)</strong>: Thiết lập cấp độ (TRACE, DEBUG, INFO, WARN, ERROR, FATAL, OFF) cho toàn bộ ứng dụng hoặc cho các package/lớp cụ thể (ví dụ: <code>logging.level.root=WARN</code>, <code>logging.level.com.example.web=DEBUG</code>).</li>
                        <li><strong>Ghi log ra tệp (File Logging)</strong>: Cấu hình để ghi log ra tệp cụ thể (<code>logging.file.name=myapp.log</code>) hoặc thư mục (<code>logging.file.path=/var/log/myapp</code>).</li>
                        <li><strong>Tùy chỉnh mẫu log (Log Pattern)</strong>: Thay đổi định dạng của các thông điệp log (<code>logging.pattern.console=%d{HH:mm:ss.SSS} [%thread] %-5level %logger{36} - %msg%n</code>).</li>
                        <li><strong>Sử dụng tệp cấu hình riêng</strong>: Cung cấp tệp cấu hình dành riêng cho hệ thống log (<code>logback-spring.xml</code>, <code>log4j2-spring.xml</code>).</li>
                    </ul>
                `
        },
        {
            category: "Giới thiệu về Spring Boot",
            id: "springboot-property-file-location",
            question: "Theo mặc định, Spring Boot tìm kiếm tệp thuộc tính ở đâu?",
            content: `
                    <p class="mb-4">Spring Boot sẽ tìm kiếm các tệp <code>application.properties</code> và <code>application.yml</code> theo một thứ tự ưu tiên nhất định. Các vị trí sau sẽ được quét (theo thứ tự ưu tiên giảm dần):</p>
                    <ol class="list-decimal list-inside mb-4 space-y-1">
                        <li>Một thư mục con <code>/config</code> của thư mục hiện tại (<code>./config/</code>).</li>
                        <li>Thư mục hiện tại (<code>./</code>).</li>
                        <li>Một thư mục <code>/config</code> trên classpath (<code>classpath:/config/</code>).</li>
                        <li>Thư mục gốc của classpath (<code>classpath:/</code>).</li>
                    </ol>
                    <p>Thứ tự này cho phép các thuộc tính được định nghĩa ở vị trí ưu tiên cao hơn (ví dụ: trong <code>./config/</code>) ghi đè lên các thuộc tính cùng tên ở vị trí ưu tiên thấp hơn (ví dụ: trong <code>classpath:/</code>).</p>
                `
        },
        {
            category: "Giới thiệu về Spring Boot",
            id: "springboot-profile-specific-properties",
            question: "Làm thế nào để bạn định nghĩa các tệp thuộc tính dành riêng cho profile?",
            content: `
                    <p class="mb-4">Bạn có thể tạo các tệp thuộc tính dành riêng cho các môi trường khác nhau (ví dụ: dev, test, prod) bằng cách tuân theo quy ước đặt tên: <strong><code>application-{profile}.properties</code></strong> (hoặc <code>.yml</code>).</p>
                    <p class="mb-2">Ví dụ:</p>
                    <ul class="list-disc list-inside mb-4 space-y-1">
                        <li><code>application-dev.properties</code>: Các thuộc tính chỉ dành cho môi trường phát triển.</li>
                        <li><code>application-prod.properties</code>: Các thuộc tính chỉ dành cho môi trường sản xuất.</li>
                        <li><code>application.properties</code>: Chứa các thuộc tính chung cho tất cả các môi trường.</li>
                    </ul>
                    <p>Khi một profile được kích hoạt (ví dụ: <code>spring.profiles.active=prod</code>), Spring Boot sẽ tải cả tệp <code>application.properties</code> chung và tệp dành riêng cho profile đó. Các thuộc tính trong tệp dành riêng cho profile sẽ <strong>ghi đè</strong> lên các thuộc tính trong tệp chung.</p>
                `
        },
        {
            category: "Giới thiệu về Spring Boot",
            id: "springboot-access-properties",
            question: "Làm thế nào để bạn truy cập các thuộc tính được định nghĩa trong các tệp thuộc tính?",
            content: `
                    <p class="mb-4">Có hai cách chính để truy cập các thuộc tính đã cấu hình:</p>
                    <h4 class="font-semibold text-lg mb-2">1. Sử dụng annotation <code>@Value</code></h4>
                    <p class="mb-2">Đây là cách đơn giản để tiêm một giá trị thuộc tính duy nhất vào một trường trong bean của bạn.</p>
                    <div class="code-block mb-4">
                        <button class="copy-btn"><i class="far fa-copy"></i> Copy</button>
                        <pre><code>@Component
public class MyComponent {
    @Value("\${app.message}")
    private String message;

    public void showMessage() {
        System.out.println(this.message);
    }
}</code></pre>
                    </div>
                    <h4 class="font-semibold text-lg mb-2">2. Sử dụng annotation <code>@ConfigurationProperties</code></h4>
                    <p class="mb-2">Đây là cách tiếp cận được khuyên dùng khi bạn có nhiều thuộc tính liên quan với nhau. Nó cho phép bạn ánh xạ một nhóm các thuộc tính vào một đối tượng Java (POJO) một cách có cấu trúc và an toàn về kiểu.</p>
                    <div class="code-block">
                        <button class="copy-btn"><i class="far fa-copy"></i> Copy</button>
                        <pre><code>@ConfigurationProperties(prefix = "app.info")
public class AppInfoProperties {
    private String name;
    private String version;
    // Getters and Setters
}

@EnableConfigurationProperties(AppInfoProperties.class)
@Configuration
public class AppConfig {}

@Service
public class AppService {
    private final AppInfoProperties appInfo;
    public AppService(AppInfoProperties appInfo) {
        this.appInfo = appInfo;
    }
    public void printAppInfo() {
        System.out.println("App Name: " + appInfo.getName());
        System.out.println("App Version: " + appInfo.getVersion());
    }
}</code></pre>
                    </div>
                `
        },
        {
            category: "Giới thiệu về Spring Boot",
            id: "springboot-mysql-config",
            question: "Cần định nghĩa những thuộc tính nào để cấu hình MySQL bên ngoài?",
            content: `
                    <p class="mb-4">Để cấu hình một cơ sở dữ liệu MySQL bên ngoài trong Spring Boot, bạn cần chỉ định URL, tên người dùng (username) và mật khẩu (password) cho <code>DataSource</code>.</p>
                    <h4 class="font-semibold text-lg mb-2">Các thuộc tính trong <code>application.properties</code>:</h4>
                    <div class="code-block mb-4">
                        <button class="copy-btn"><i class="far fa-copy"></i> Copy</button>
                        <pre><code>spring.datasource.url=jdbc:mysql://localhost:3306/ten_database_cua_ban
spring.datasource.username=ten_nguoi_dung
spring.datasource.password=mat_khau
spring.datasource.driver-class-name=com.mysql.cj.jdbc.Driver</code></pre>
                    </div>
                    <p class="mb-2">Bạn cũng cần thêm dependency <code>mysql-connector-java</code> và <code>spring-boot-starter-data-jdbc</code> vào <code>pom.xml</code>:</p>
                    <div class="code-block">
                        <button class="copy-btn"><i class="far fa-copy"></i> Copy</button>
                        <pre><code>&lt;dependency&gt;
    &lt;groupId&gt;mysql&lt;/groupId&gt;
    &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt;
    &lt;scope&gt;runtime&lt;/scope&gt;
&lt;/dependency&gt;
&lt;dependency&gt;
    &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;
    &lt;artifactId&gt;spring-boot-starter-data-jdbc&lt;/artifactId&gt;
&lt;/dependency&gt;</code></pre>
                    </div>
                `
        },
        {
            category: "Giới thiệu về Spring Boot",
            id: "springboot-schema-initial-data",
            question: "Làm thế nào để cấu hình schema mặc định và dữ liệu ban đầu?",
            content: `
                    <p class="mb-4">Spring Boot có thể tự động khởi tạo schema và nạp dữ liệu vào cơ sở dữ liệu lúc khởi động bằng cách sử dụng các tệp tin SQL <code>schema.sql</code> và <code>data.sql</code>, đặt trong thư mục <code>src/main/resources</code>.</p>
                    <h4 class="font-semibold text-lg mb-2">Ví dụ <code>schema.sql</code>:</h4>
                    <div class="code-block mb-4">
                        <button class="copy-btn"><i class="far fa-copy"></i> Copy</button>
                        <pre><code>DROP TABLE IF EXISTS NGUOI_DUNG;
CREATE TABLE NGUOI_DUNG (
    id INT AUTO_INCREMENT PRIMARY KEY,
    ten_dang_nhap VARCHAR(250) NOT NULL,
    email VARCHAR(250) NOT NULL
);</code></pre>
                    </div>
                    <h4 class="font-semibold text-lg mb-2">Ví dụ <code>data.sql</code>:</h4>
                    <div class="code-block mb-4">
                        <button class="copy-btn"><i class="far fa-copy"></i> Copy</button>
                        <pre><code>INSERT INTO NGUOI_DUNG (ten_dang_nhap, email) VALUES
('admin', 'admin@example.com'),
('user', 'user@example.com');</code></pre>
                    </div>
                    <p>Theo mặc định, việc khởi tạo này chỉ được bật cho các cơ sở dữ liệu nhúng. Để luôn thực hiện với các cơ sở dữ liệu khác, thêm thuộc tính:</p>
                    <div class="code-block">
                        <button class="copy-btn"><i class="far fa-copy"></i> Copy</button>
                        <pre><code>spring.datasource.initialization-mode=always</code></pre>
                    </div>
                `
        },
        {
            category: "Giới thiệu về Spring Boot",
            id: "springboot-fat-jar",
            question: "'Fat JAR' là gì? Nó khác gì so với JAR gốc?",
            content: `
                    <p class="mb-4"><strong>Fat JAR</strong> (hay còn gọi là "executable JAR") là một tệp JAR chứa không chỉ mã đã biên dịch của ứng dụng bạn mà còn chứa tất cả các thư viện (dependencies) mà ứng dụng cần để chạy. Điều này làm cho ứng dụng có thể chạy độc lập chỉ với một tệp JAR duy nhất.</p>
                    <h4 class="font-semibold text-lg mb-2">Sự khác biệt chính so với JAR gốc:</h4>
                    <ul class="list-disc list-inside mb-4 space-y-1">
                        <li><strong>Phụ thuộc (Dependencies)</strong>: JAR gốc chỉ chứa mã nguồn của bạn. Fat JAR chứa cả mã nguồn của bạn và tất cả các file JAR của thư viện phụ thuộc.</li>
                        <li><strong>Khả năng thực thi</strong>: JAR gốc thường không thể tự thực thi. Fat JAR được tạo bởi Spring Boot có thể chạy trực tiếp từ dòng lệnh bằng <code>java -jar myapp.jar</code>.</li>
                    </ul>
                    <p>Để tạo một fat JAR, bạn cần sử dụng <code>spring-boot-maven-plugin</code> trong <code>pom.xml</code>:</p>
                    <div class="code-block">
                        <button class="copy-btn"><i class="far fa-copy"></i> Copy</button>
                        <pre><code>&lt;build&gt;
    &lt;plugins&gt;
        &lt;plugin&gt;
            &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;
            &lt;artifactId&gt;spring-boot-maven-plugin&lt;/artifactId&gt;
        &lt;/plugin&gt;
    &lt;/plugins&gt;
&lt;/build&gt;</code></pre>
                    </div>
                `
        },
        {
            category: "Giới thiệu về Spring Boot",
            id: "springboot-embedded-vs-war",
            question: "Sự khác biệt giữa container nhúng và WAR là gì?",
            content: `
                    <div class="grid md:grid-cols-2 gap-6">
                        <div class="p-4 border rounded-lg bg-white">
                            <h4 class="font-bold text-lg text-blue-700 mb-2">Container nhúng (Embedded Container)</h4>
                            <ul class="list-disc list-inside space-y-1">
                                <li>Là một máy chủ (server) như Tomcat, Jetty được đóng gói ngay bên trong tệp JAR của ứng dụng.</li>
                                <li>Giúp ứng dụng có thể chạy độc lập như một tệp "fat JAR".</li>
                                <li>Mỗi ứng dụng chạy trên máy chủ nhúng của riêng nó.</li>
                            </ul>
                        </div>
                        <div class="p-4 border rounded-lg bg-white">
                            <h4 class="font-bold text-lg text-green-700 mb-2">WAR (Web Application Archive)</h4>
                            <ul class="list-disc list-inside space-y-1">
                                <li>Là một file định dạng chuẩn để đóng gói một ứng dụng web Java.</li>
                                <li>Không thể tự chạy mà phải được triển khai (deploy) lên một máy chủ ứng dụng (Application Server) bên ngoài.</li>
                                <li>Một máy chủ ứng dụng có thể chạy nhiều ứng dụng WAR cùng một lúc.</li>
                            </ul>
                        </div>
                    </div>
                `
        },
        {
            category: "Giới thiệu về Spring Boot",
            id: "springboot-embedded-containers",
            question: "Spring Boot hỗ trợ những container nhúng nào?",
            content: `
                    <p class="mb-4">Spring Boot hỗ trợ ba loại container nhúng chính:</p>
                    <ul class="list-disc list-inside mb-4 space-y-1">
                        <li><strong>Tomcat</strong>: Mặc định.</li>
                        <li><strong>Jetty</strong></li>
                        <li><strong>Undertow</strong></li>
                    </ul>
                    <p>Để chuyển sang Jetty hoặc Undertow, bạn cần loại bỏ <code>spring-boot-starter-tomcat</code> mặc định và thêm vào dependency cho container bạn muốn.</p>
                    <h4 class="font-semibold text-lg mb-2">Ví dụ chuyển sang Jetty:</h4>
                    <div class="code-block">
                        <button class="copy-btn"><i class="far fa-copy"></i> Copy</button>
                        <pre><code>&lt;dependency&gt;
    &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;
    &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt;
    &lt;exclusions&gt;
        &lt;exclusion&gt;
            &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;
            &lt;artifactId&gt;spring-boot-starter-tomcat&lt;/artifactId&gt;
        &lt;/exclusion&gt;
    &lt;/exclusions&gt;
&lt;/dependency&gt;
&lt;dependency&gt;
    &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;
    &lt;artifactId&gt;spring-boot-starter-jetty&lt;/artifactId&gt;
&lt;/dependency&gt;</code></pre>
                    </div>
                `
        },
        {
            category: "Giới thiệu về Spring Boot",
            id: "springboot-how-auto-config-works",
            question: "Làm thế nào Spring Boot biết cần phải cấu hình những gì?",
            content: `
                    <p class="mb-4">Spring Boot biết cần cấu hình những gì thông qua cơ chế <strong>Tự động cấu hình (Auto-configuration)</strong>. Quá trình này hoạt động như sau:</p>
                    <ol class="list-decimal list-inside mb-4 space-y-1">
                        <li><strong>Starter Dependencies</strong>: Khi bạn thêm một "starter", bạn đang thêm một tập hợp các thư viện phổ biến vào classpath.</li>
                        <li><strong>Quét <code>spring.factories</code></strong>: Spring Boot tìm kiếm file <code>META-INF/spring.factories</code> trong tất cả các JAR trên classpath để tìm các lớp tự động cấu hình.</li>
                        <li><strong>Annotations có điều kiện (<code>@ConditionalOn...</code>)</strong>: Mỗi lớp tự động cấu hình sử dụng các annotation điều kiện để quyết định xem có nên được kích hoạt hay không (ví dụ: <code>@ConditionalOnClass</code>, <code>@ConditionalOnBean</code>, <code>@ConditionalOnProperty</code>).</li>
                    </ol>
                    <p>Khi các điều kiện được đáp ứng, lớp <code>@Configuration</code> đó sẽ được nạp và các bean mà nó định nghĩa sẽ được tạo ra.</p>
                `
        },
        {
            category: "Giới thiệu về Spring Boot",
            id: "springboot-enableautoconfiguration",
            question: "<code>@EnableAutoConfiguration</code> làm gì?",
            content: `
                    <p class="mb-4">Annotation <code>@EnableAutoConfiguration</code> kích hoạt cơ chế tự động cấu hình của Spring Boot.</p>
                    <p>Khi được sử dụng, nó yêu cầu Spring Boot "đoán" xem bạn muốn cấu hình ứng dụng của mình như thế nào dựa trên các JAR phụ thuộc (dependencies) mà bạn đã thêm. Ví dụ, nếu <code>spring-boot-starter-web</code> có trên classpath, Spring Boot sẽ giả định bạn đang xây dựng một ứng dụng web và tự động cấu hình DispatcherServlet và một máy chủ Tomcat nhúng.</p>
                    <p>Annotation này thường không được sử dụng trực tiếp vì nó đã được bao gồm trong annotation tiện ích <code>@SpringBootApplication</code>.</p>
                `
        },
        {
            category: "Giới thiệu về Spring Boot",
            id: "springboot-application-annotation",
            question: "<code>@SpringBootApplication</code> làm gì?",
            content: `
                    <p class="mb-4"><code>@SpringBootApplication</code> là một annotation tiện ích, kết hợp ba annotation quan trọng khác lại với nhau:</p>
                    <ul class="list-disc list-inside mb-4 space-y-1">
                        <li><strong><code>@Configuration</code></strong>: Đánh dấu lớp là một nguồn định nghĩa bean.</li>
                        <li><strong><code>@EnableAutoConfiguration</code></strong>: Bật cơ chế tự động cấu hình của Spring Boot.</li>
                        <li><strong><code>@ComponentScan</code></strong>: Bật cơ chế quét component, tìm kiếm các component, configuration và service trong cùng package và các package con.</li>
                    </ul>
                    <p>Việc sử dụng <code>@SpringBootApplication</code> tương đương với việc sử dụng cả ba annotation trên.</p>
                    <h4 class="font-semibold text-lg mb-2">Ví dụ về lớp ứng dụng chính:</h4>
                    <div class="code-block">
                        <button class="copy-btn"><i class="far fa-copy"></i> Copy</button>
                        <pre><code>import org.springframework.boot.SpringApplication;
import org.springframework.boot.autoconfigure.SpringBootApplication;

@SpringBootApplication
public class MyWebAppApplication {
    public static void main(String[] args) {
        SpringApplication.run(MyWebAppApplication.class, args);
    }
}</code></pre>
                    </div>
                `
        },
        {
            category: "Giới thiệu về Spring Boot",
            id: "springboot-component-scanning",
            question: "Spring Boot có thực hiện component scanning không? Nó tìm kiếm ở đâu theo mặc định?",
            content: `
                    <p class="mb-4">Có, Spring Boot thực hiện <strong>component scanning</strong> (quét thành phần).</p>
                    <p>Theo mặc định, việc quét này được kích hoạt bởi annotation <code>@ComponentScan</code> (mà <code>@SpringBootApplication</code> đã bao gồm). Spring Boot sẽ tự động quét các lớp được chú thích bằng <code>@Component</code> (và các stereotype của nó như <code>@Service</code>, <code>@Repository</code>, <code>@Controller</code>) bắt đầu từ package của lớp chính (lớp được chú thích bằng <code>@SpringBootApplication</code>) và tất cả các package con của nó.</p>
                    <p>Bạn có thể tùy chỉnh phạm vi quét bằng cách sử dụng thuộc tính <code>scanBasePackages</code> trong annotation <code>@SpringBootApplication</code>.</p>
                `
        },
        {
            category: "Giới thiệu về Spring Boot",
            id: "springboot-datasource-jdbctemplate-auto-config",
            question: "<code>DataSource</code> và <code>JdbcTemplate</code> được tự động cấu hình như thế nào?",
            content: `
                    <p class="mb-4"><code>DataSource</code> và <code>JdbcTemplate</code> được cấu hình tự động bởi các lớp Auto-Configuration trong module <code>spring-boot-autoconfigure</code>.</p>
                    <ul class="list-disc list-inside mb-4 space-y-1">
                        <li><strong><code>DataSourceAutoConfiguration</code></strong>: Tạo ra một bean <code>DataSource</code> nếu phát hiện các lớp liên quan đến cơ sở dữ liệu trên classpath và bạn đã cung cấp các thuộc tính kết nối.</li>
                        <li><strong><code>JdbcTemplateAutoConfiguration</code></strong>: Tạo một bean <code>JdbcTemplate</code> sau khi một bean <code>DataSource</code> đã được tạo thành công, và tự động sử dụng <code>DataSource</code> đó.</li>
                    </ul>
                    <p>Sau khi Spring Boot đã tự động cấu hình xong, bạn có thể tiêm (inject) <code>DataSource</code> hoặc <code>JdbcTemplate</code> trực tiếp vào các bean của mình bằng <code>@Autowired</code>.</p>
                `
        },
        {
            category: "Giới thiệu về Spring Boot",
            id: "springboot-spring-factories",
            question: "Tệp <code>spring.factories</code> dùng để làm gì?",
            content: `
                    <p class="mb-4">Tệp <code>spring.factories</code>, nằm trong đường dẫn <code>META-INF/spring.factories</code> trên classpath, được cơ chế Tự động cấu hình (Auto-Configuration) của Spring Boot sử dụng để xác định vị trí của các lớp cấu hình tự động.</p>
                    <p>Mỗi module cung cấp các lớp cấu hình tự động cần phải có một tệp <code>META-INF/spring.factories</code>. Bên trong tệp này, có một khóa là <code>org.springframework.boot.autoconfigure.EnableAutoConfiguration</code>, và giá trị của nó là một danh sách các lớp cấu hình tự động mà module đó cung cấp.</p>
                    <p>Khi ứng dụng Spring Boot khởi động, nó sẽ quét tất cả các tệp <code>spring.factories</code> trên classpath, đọc danh sách các lớp cấu hình dưới khóa này, và sau đó đánh giá xem có nên áp dụng từng cấu hình hay không dựa trên các điều kiện (<code>@Conditional</code>) được định nghĩa trong mỗi lớp.</p>
                `
        },
        {
            category: "Giới thiệu về Spring Boot",
            id: "springboot-customize-auto-config",
            question: "Làm thế nào để tùy chỉnh cấu hình tự động của Spring?",
            content: `
                    <p class="mb-4">Bạn có thể tùy chỉnh hoặc tạo ra cấu hình tự động của riêng mình bằng cách tạo một module "auto-configuration". Quá trình này bao gồm các bước sau:</p>
                    <ol class="list-decimal list-inside mb-4 space-y-1">
                        <li><strong>Tạo một Lớp Cấu hình (Configuration Class)</strong>: Một lớp Java được chú thích bằng <code>@Configuration</code> chứa các phương thức <code>@Bean</code>.</li>
                        <li><strong>Sử dụng Annotation Điều kiện</strong>: Sử dụng các annotation <code>@ConditionalOn...</code> (ví dụ: <code>@ConditionalOnClass</code>, <code>@ConditionalOnProperty</code>) trên lớp cấu hình hoặc trên các phương thức <code>@Bean</code> để chỉ định khi nào cấu hình này nên được áp dụng.</li>
                        <li><strong>Tạo tệp <code>spring.factories</code></strong>: Trong module của bạn, tạo một tệp tại <code>src/main/resources/META-INF/spring.factories</code>.</li>
                        <li><strong>Đăng ký Lớp Cấu hình</strong>: Trong tệp <code>spring.factories</code>, thêm một mục nhập để đăng ký lớp cấu hình của bạn.</li>
                    </ol>
                `
        },
        {
            category: "Giới thiệu về Spring Boot",
            id: "springboot-conditional-annotations",
            question: "Các ví dụ về annotation <code>@Conditional</code> là gì? Chúng được sử dụng như thế nào?",
            content: `
                    <p class="mb-4">Spring Boot cung cấp nhiều annotation <code>@Conditional</code> để kiểm soát việc kích hoạt các lớp cấu hình tự động. Chúng được sử dụng để chỉ định các điều kiện mà theo đó một cấu hình (<code>@Configuration</code>) hoặc một bean (<code>@Bean</code>) nên được tạo.</p>
                    <h4 class="font-semibold text-lg mb-2">Một số ví dụ phổ biến:</h4>
                    <ul class="list-disc list-inside mb-4 space-y-1">
                        <li><strong><code>@ConditionalOnBean</code></strong>: Chỉ áp dụng nếu một bean cụ thể đã tồn tại.</li>
                        <li><strong><code>@ConditionalOnMissingBean</code></strong>: Chỉ áp dụng nếu một bean cụ thể chưa tồn tại.</li>
                        <li><strong><code>@ConditionalOnClass</code></strong>: Chỉ áp dụng nếu một lớp cụ thể có mặt trên classpath.</li>
                        <li><strong><code>@ConditionalOnProperty</code></strong>: Chỉ áp dụng nếu một thuộc tính có giá trị cụ thể.</li>
                        <li><strong><code>@ConditionalOnWebApplication</code></strong>: Chỉ áp dụng nếu đây là một ứng dụng web.</li>
                    </ul>
                    <p>Các annotation này được đặt ngay trên một lớp <code>@Configuration</code> hoặc một phương thức <code>@Bean</code>.</p>
                `
        },
        {
            category: "Giới thiệu về Spring Boot",
            id: "springboot-actuator-value",
            question: "Spring Boot Actuator cung cấp giá trị gì?",
            content: `
                    <p class="mb-4">Spring Boot Actuator cung cấp các tính năng sẵn sàng cho môi trường sản xuất (production-ready) để <strong>giám sát</strong> và <strong>quản lý</strong> ứng dụng của bạn.</p>
                    <p class="mb-4">Giá trị chính mà Actuator mang lại là nó cung cấp các "endpoint" (điểm cuối) mà không cần bạn phải tự viết mã. Các tính năng chính bao gồm:</p>
                    <ul class="list-disc list-inside mb-4 space-y-1">
                        <li><strong>Kiểm tra sức khỏe (Health checks)</strong>: Endpoint <code>/actuator/health</code> cho biết trạng thái của ứng dụng.</li>
                        <li><strong>Số liệu (Metrics)</strong>: Endpoint <code>/actuator/metrics</code> cung cấp các số liệu chi tiết về hiệu suất.</li>
                        <li><strong>Thông tin ứng dụng (Application Info)</strong>: Endpoint <code>/actuator/info</code> hiển thị thông tin tùy chỉnh về ứng dụng.</li>
                        <li><strong>Quản lý môi trường (Environment Management)</strong>: Endpoint <code>/actuator/env</code> cho phép xem tất cả các thuộc tính cấu hình.</li>
                    </ul>
                    <p>Để sử dụng, bạn chỉ cần thêm dependency <code>spring-boot-starter-actuator</code> vào dự án.</p>
                `
        },
        {
            category: "Giới thiệu về Spring Boot",
            id: "springboot-actuator-protocols",
            question: "Hai giao thức bạn có thể sử dụng để truy cập các endpoint của Actuator là gì?",
            content: `
                    <p class="mb-4">Bạn có thể sử dụng hai giao thức chính để truy cập các endpoint của Spring Boot Actuator:</p>
                    <h4 class="font-semibold text-lg mb-2">1. HTTP</h4>
                    <p class="mb-2">Đây là giao thức phổ biến nhất. Các endpoint được hiển thị dưới dạng các API REST, có thể truy cập qua trình duyệt hoặc bất kỳ công cụ HTTP client nào.</p>
                    <ul class="list-disc list-inside mb-4 space-y-1">
                        <li><strong>Ưu điểm</strong>: Dễ sử dụng, có thể truy cập từ bất kỳ đâu.</li>
                        <li><strong>Ví dụ</strong>: <code>http://localhost:8080/actuator/health</code>.</li>
                    </ul>
                    <h4 class="font-semibold text-lg mb-2">2. JMX (Java Management Extensions)</h4>
                    <p class="mb-2">Là một công nghệ tiêu chuẩn của Java để giám sát và quản lý các ứng dụng. Các endpoint của Actuator cũng có thể được hiển thị qua JMX.</p>
                    <ul class="list-disc list-inside mb-4 space-y-1">
                        <li><strong>Ưu điểm</strong>: Cung cấp quyền truy cập phong phú hơn vào các hoạt động bên trong của ứng dụng.</li>
                        <li><strong>Cách truy cập</strong>: Sử dụng các công cụ như JConsole hoặc VisualVM.</li>
                    </ul>
                `
        },
        {
            category: "Giới thiệu về Spring Boot",
            id: "springboot-actuator-endpoints",
            question: "Các endpoint nào của Actuator được cung cấp sẵn?",
            content: `
                    <p class="mb-4">Spring Boot Actuator cung cấp một loạt các endpoint tích hợp sẵn để giám sát và tương tác với ứng dụng. Một số endpoint quan trọng bao gồm:</p>
                    <ul class="list-disc list-inside mb-4 space-y-1">
                        <li><code>health</code>: Thông tin sức khỏe của ứng dụng. (Mặc định hiển thị qua Web)</li>
                        <li><code>info</code>: Thông tin tùy chỉnh về ứng dụng. (Mặc định hiển thị qua Web)</li>
                        <li><code>beans</code>: Danh sách đầy đủ tất cả các Spring bean. (Không mặc định)</li>
                        <li><code>metrics</code>: Các thông tin số liệu (metrics) của ứng dụng. (Không mặc định)</li>
                        <li><code>loggers</code>: Hiển thị và cho phép thay đổi cấp độ ghi log. (Không mặc định)</li>
                        <li><code>env</code>: Các thuộc tính từ môi trường của Spring. (Không mặc định)</li>
                        <li><code>mappings</code>: Danh sách tất cả các đường dẫn <code>@RequestMapping</code>. (Không mặc định)</li>
                        <li><code>threaddump</code>: Thực hiện một thread dump của JVM. (Không mặc định)</li>
                        <li><code>shutdown</code>: Cho phép tắt ứng dụng an toàn. (Mặc định bị vô hiệu hóa)</li>
                    </ul>
                    <p>Để hiển thị các endpoint khác ngoài <code>health</code> và <code>info</code> qua web, bạn cần cấu hình trong <code>application.properties</code> (ví dụ: <code>management.endpoints.web.exposure.include=health,info,metrics,loggers</code>).</p>
                `
        },
        {
            category: "Giới thiệu về Spring Boot",
            id: "springboot-actuator-info-endpoint",
            question: "Endpoint <code>info</code> dùng để làm gì? Làm thế nào để cung cấp dữ liệu cho nó?",
            content: `
                    <p class="mb-4">Endpoint <code>info</code> của Actuator được sử dụng để hiển thị các thông tin tùy ý, không nhạy cảm về ứng dụng của bạn (ví dụ: tên ứng dụng, phiên bản, mô tả, thông tin về bản build).</p>
                    <h4 class="font-semibold text-lg mb-2">Cách cung cấp dữ liệu:</h4>
                    <ul class="list-disc list-inside mb-4 space-y-1">
                        <li><strong>Sử dụng tệp <code>application.properties</code></strong>: Thêm các thuộc tính với tiền tố <code>info.</code> (ví dụ: <code>info.app.name=My Awesome App</code>).</li>
                        <li><strong>Triển khai một <code>InfoContributor</code> bean</strong>: Để có logic phức tạp hơn, bạn có thể tạo một bean triển khai interface <code>InfoContributor</code>.</li>
                    </ul>
                    <h4 class="font-semibold text-lg mb-2">Ví dụ <code>InfoContributor</code>:</h4>
                    <div class="code-block">
                        <button class="copy-btn"><i class="far fa-copy"></i> Copy</button>
                        <pre><code>import org.springframework.boot.actuate.info.Info;
import org.springframework.boot.actuate.info.InfoContributor;
import org.springframework.stereotype.Component;

@Component
public class SystemInfoContributor implements InfoContributor {
    @Override
    public void contribute(Info.Builder builder) {
        builder.withDetail("os_name", System.getProperty("os.name"));
        builder.withDetail("java_version", System.getProperty("java.version"));
    }
}</code></pre>
                    </div>
                `
        },
        {
            category: "Giới thiệu về Spring Boot",
            id: "springboot-actuator-loggers-endpoint",
            question: "Làm thế nào để thay đổi cấp độ ghi log của một package bằng endpoint <code>loggers</code>?",
            content: `
                    <p class="mb-4">Endpoint <code>loggers</code> của Actuator cho phép bạn xem và thay đổi cấp độ ghi log (logging level) của ứng dụng tại thời điểm chạy mà không cần khởi động lại.</p>
                    <h4 class="font-semibold text-lg mb-2">Các bước:</h4>
                    <ol class="list-decimal list-inside mb-4 space-y-1">
                        <li><strong>Hiển thị endpoint <code>loggers</code></strong>: Thêm <code>management.endpoints.web.exposure.include=loggers</code> vào <code>application.properties</code>.</li>
                        <li><strong>Xem cấp độ log hiện tại</strong>: Truy cập <code>/actuator/loggers/{tên_package_hoặc_lớp}</code>.</li>
                        <li><strong>Thay đổi cấp độ log</strong>: Gửi một yêu cầu <code>POST</code> đến URL của logger đó với body là JSON chỉ định <code>configuredLevel</code> mới (ví dụ: <code>{"configuredLevel": "DEBUG"}</code>).</li>
                    </ol>
                `
        },
        {
            category: "Giới thiệu về Spring Boot",
            id: "springboot-actuator-access-by-tag",
            question: "Làm thế nào để truy cập một endpoint bằng cách sử dụng tag?",
            content: `
                    <p class="mb-4">Việc sử dụng tag cho phép bạn lọc kết quả từ các endpoint của Actuator, đặc biệt hữu ích với endpoint <code>metrics</code>. Bạn có thể truy vấn các số liệu cho các chiều (dimension) cụ thể.</p>
                    <p class="mb-2">Cú pháp để sử dụng tag là thêm tham số <code>tag=KEY:VALUE</code> vào URL.</p>
                    <h4 class="font-semibold text-lg mb-2">Ví dụ:</h4>
                    <ul class="list-disc list-inside mb-4 space-y-1">
                        <li>Lọc các request HTTP có mã trạng thái là 200: <code>/actuator/metrics/http.server.requests?tag=status:200</code></li>
                        <li>Lọc bộ nhớ heap đã sử dụng: <code>/actuator/metrics/jvm.memory.used?tag=area:heap</code></li>
                        <li>Kết hợp nhiều tag: <code>/actuator/metrics/http.server.requests?tag=method:GET&tag=status:200</code></li>
                    </ul>
                `
        },
        {
            category: "Giới thiệu về Spring Boot",
            id: "springboot-actuator-metrics",
            question: "<code>metrics</code> dùng để làm gì?",
            content: `
                    <p class="mb-4">Endpoint <code>metrics</code> của Actuator được sử dụng để <strong>kiểm tra các số liệu</strong> (metrics) được ứng dụng thu thập trong quá trình chạy. Nó cung cấp một cái nhìn sâu sắc về hiệu suất và hành vi của ứng dụng.</p>
                    <h4 class="font-semibold text-lg mb-2">Các tính năng chính:</h4>
                    <ul class="list-disc list-inside mb-4 space-y-1">
                        <li>Cung cấp danh sách tất cả các metrics có sẵn.</li>
                        <li>Cho phép xem chi tiết một metric cụ thể (ví dụ: <code>/actuator/metrics/process.cpu.usage</code>).</li>
                        <li>Cho phép lọc dữ liệu bằng cách sử dụng các tag.</li>
                    </ul>
                    <p>Một số metrics có sẵn: JVM metrics (bộ nhớ, GC), system metrics (CPU), application metrics (HTTP requests), DataSource metrics (kết nối).</p>
                    <p>Theo mặc định, endpoint này không được hiển thị qua web. Bạn cần kích hoạt nó trong <code>application.properties</code> (ví dụ: <code>management.endpoints.web.exposure.include=metrics</code>).</p>
                `
        },
        {
            category: "Giới thiệu về Spring Boot",
            id: "springboot-custom-metric",
            question: "Làm thế nào để tạo một metric tùy chỉnh (custom metric) có hoặc không có tag?",
            content: `
                    <p class="mb-4">Bạn có thể tạo các metric tùy chỉnh trong Spring Boot Actuator bằng cách sử dụng <strong><code>MeterRegistry</code></strong> từ Micrometer. Micrometer cho phép bạn đăng ký nhiều loại "meter" khác nhau sẽ được hiển thị qua endpoint <code>/actuator/metrics</code>.</p>
                    <h4 class="font-semibold text-lg mb-2">Các loại meter cơ bản:</h4>
                    <ul class="list-disc list-inside mb-4 space-y-1">
                        <li>Counter</li>
                        <li>Gauge</li>
                        <li>Timer</li>
                        <li>Distribution Summary</li>
                    </ul>
                    <p>Bạn có thể thêm các <strong>"tag"</strong> (thẻ) để tạo ra các chiều (dimensions) cho metric của mình, giúp cho việc lọc và phân tích dữ liệu trở nên linh hoạt hơn.</p>
                    <h4 class="font-semibold text-lg mb-2">Ví dụ tạo counter với tag:</h4>
                    <div class="code-block">
                        <button class="copy-btn"><i class="far fa-copy"></i> Copy</button>
                        <pre><code>import io.micrometer.core.instrument.Counter;
import io.micrometer.core.instrument.MeterRegistry;
import org.springframework.stereotype.Component;

@Component
public class ObjectStorageService {
    private final Counter objectCounterWithTags;

    public ObjectStorageService(MeterRegistry meterRegistry) {
        this.objectCounterWithTags = meterRegistry.counter("storage.object.count", "type", "database");
    }

    public void saveObject() {
        this.objectCounterWithTags.increment();
    }
}</code></pre>
                    </div>
                `
        },
        {
            category: "Giới thiệu về Spring Boot",
            id: "springboot-health-indicator",
            question: "Health Indicator là gì?",
            content: `
                    <p class="mb-4"><strong>Health Indicator</strong> (Chỉ báo Sức khỏe) là một thành phần được endpoint <code>/actuator/health</code> sử dụng để kiểm tra xem một phần của hệ thống có đang ở trạng thái tốt và sẵn sàng xử lý các yêu cầu hay không.</p>
                    <p class="mb-4">Endpoint <code>/actuator/health</code> sẽ tổng hợp kết quả từ tất cả các <code>HealthIndicator</code> đã được đăng ký để đưa ra trạng thái sức khỏe cuối cùng cho toàn bộ ứng dụng. Các công cụ giám sát thường sử dụng endpoint này để tự động kiểm tra trạng thái hệ thống và gửi cảnh báo nếu có sự cố.</p>
                    <p>Để tạo một <code>HealthIndicator</code> tùy chỉnh, bạn cần tạo một Spring Bean triển khai interface <code>HealthIndicator</code>.</p>
                    <h4 class="font-semibold text-lg mb-2">Ví dụ <code>HealthIndicator</code> tùy chỉnh:</h4>
                    <div class="code-block">
                        <button class="copy-btn"><i class="far fa-copy"></i> Copy</button>
                        <pre><code>import org.springframework.boot.actuate.health.Health;
import org.springframework.boot.actuate.health.HealthIndicator;
import org.springframework.stereotype.Component;

@Component
public class MyCustomHealthIndicator implements HealthIndicator {
    @Override
    public Health health() {
        boolean isSystemReady = true; // Logic kiểm tra của bạn
        if (!isSystemReady) {
            return Health.down().withDetail("reason", "Dịch vụ phụ thuộc không phản hồi").build();
        }
        return Health.up().withDetail("system-ready", true).build();
    }
}</code></pre>
                    </div>
                `
        },
        {
            category: "Giới thiệu về Spring Boot",
            id: "springboot-predefined-health-indicators",
            question: "Các Health Indicator nào được cung cấp sẵn?",
            content: `
                    <p class="mb-4">Spring Boot Actuator tự động cấu hình nhiều <code>HealthIndicator</code> có sẵn khi nó phát hiện các dependency tương ứng trên classpath. Điều này có nghĩa là bạn không cần phải viết mã kiểm tra cho các thành phần phổ biến.</p>
                    <h4 class="font-semibold text-lg mb-2">Một số chỉ báo sức khỏe được cung cấp sẵn:</h4>
                    <ul class="list-disc list-inside mb-4 space-y-1">
                        <li><strong><code>DiskSpaceHealthIndicator</code></strong>: Kiểm tra dung lượng đĩa còn trống.</li>
                        <li><strong><code>DataSourceHealthIndicator</code></strong>: Kiểm tra trạng thái của một <code>DataSource</code> (kết nối cơ sở dữ liệu).</li>
                        <li><strong><code>RedisHealthIndicator</code></strong>: Kiểm tra xem máy chủ Redis có đang hoạt động không.</li>
                        <li><strong><code>RabbitHealthIndicator</code></strong>: Kiểm tra xem máy chủ RabbitMQ có đang hoạt động không.</li>
                        <li><strong><code>MongoHealthIndicator</code></strong>: Kiểm tra xem cơ sở dữ liệu Mongo có đang hoạt động không.</li>
                        <li>Và nhiều loại khác cho Cassandra, Elasticsearch, JMS, Mail, v.v.</li>
                    </ul>
                `
        },
        {
            category: "Giới thiệu về Spring Boot",
            id: "springboot-health-indicator-status",
            question: "Trạng thái của Health Indicator là gì?",
            content: `
                    <p class="mb-4">Trạng thái của <code>Health Indicator</code> được dùng để thông báo cho Spring Actuator biết liệu thành phần hệ thống mà nó đang kiểm tra có hoạt động chính xác hay không.</p>
                    <h4 class="font-semibold text-lg mb-2">Mỗi <code>HealthIndicator</code> phải trả về một trong các trạng thái sau:</h4>
                    <ul class="list-disc list-inside mb-4 space-y-1">
                        <li><strong><code>UP</code></strong>: Thành phần đang hoạt động như mong đợi.</li>
                        <li><strong><code>DOWN</code></strong>: Thành phần đã gặp một lỗi không mong muốn.</li>
                        <li><strong><code>OUT_OF_SERVICE</code></strong>: Thành phần đã được đưa ra khỏi dịch vụ và không nên được sử dụng.</li>
                        <li><strong><code>UNKNOWN</code></strong>: Trạng thái của thành phần không xác định.</li>
                        <li>Trạng thái tùy chỉnh do người dùng định nghĩa.</li>
                    </ul>
                    <p>Spring Actuator sử dụng một <code>HealthAggregator</code> để tổng hợp các trạng thái và quyết định trạng thái cuối cùng cho toàn bộ ứng dụng, ánh xạ chúng tới các mã trạng thái HTTP (ví dụ: <code>UP</code> -> 200, <code>DOWN</code> -> 503).</p>
                `
        },
        {
            category: "Giới thiệu về Spring Boot",
            id: "springboot-predefined-health-indicator-statuses",
            question: "Các trạng thái Health Indicator nào được cung cấp sẵn?",
            content: `
                    <p class="mb-4">Spring Actuator cung cấp sẵn các trạng thái sau đây:</p>
                    <ul class="list-disc list-inside mb-4 space-y-1">
                        <li><strong><code>UP</code></strong>: Thành phần hoặc hệ thống con đang hoạt động như mong đợi.</li>
                        <li><strong><code>DOWN</code></strong>: Thành phần hoặc hệ thống con đã gặp một lỗi không mong muốn.</li>
                        <li><strong><code>OUT_OF_SERVICE</code></strong>: Thành phần hoặc hệ thống con đã được đưa ra khỏi dịch vụ và không nên được sử dụng.</li>
                        <li><strong><code>UNKNOWN</code></strong>: Trạng thái của thành phần hoặc hệ thống con không xác định.</li>
                    </ul>
                    <p>Dựa trên các trạng thái này, Spring sẽ tự động ánh xạ chúng tới các mã trạng thái HTTP khi bạn truy cập endpoint <code>/actuator/health</code> (ví dụ: <code>UP</code> -> HTTP 200, <code>DOWN</code> -> HTTP 503).</p>
                `
        },
        {
            category: "Giới thiệu về Spring Boot",
            id: "springboot-health-status-order",
            question: "Làm thế nào để thay đổi thứ tự ưu tiên mức độ nghiêm trọng của trạng thái Health Indicator?",
            content: `
                    <p class="mb-4">Spring Actuator cho phép bạn thay đổi thứ tự ưu tiên mức độ nghiêm trọng của các trạng thái bằng cách sử dụng thuộc tính <code>management.health.status.order</code>.</p>
                    <p class="mb-2">Thứ tự mặc định là: <code>DOWN</code>, <code>OUT_OF_SERVICE</code>, <code>UP</code>, <code>UNKNOWN</code>.</p>
                    <p><code>OrderedHealthAggregator</code> sử dụng thứ tự này để quyết định trạng thái tổng hợp cuối cùng của ứng dụng. Nó sẽ lấy trạng thái có độ ưu tiên cao nhất từ tất cả các chỉ báo.</p>
                    <h4 class="font-semibold text-lg mb-2">Ví dụ: Thêm một trạng thái tùy chỉnh <code>FATAL</code> với độ ưu tiên cao nhất:</h4>
                    <div class="code-block">
                        <button class="copy-btn"><i class="far fa-copy"></i> Copy</button>
                        <pre><code>management.health.status.order=FATAL, DOWN, OUT_OF_SERVICE, UP, UNKNOWN</code></pre>
                    </div>
                `
        },
        {
            category: "Giới thiệu về Spring Boot",
            id: "springboot-external-monitoring",
            question: "Tại sao bạn muốn tận dụng hệ thống giám sát bên ngoài của bên thứ ba?",
            content: `
                    <p class="mb-4">Việc sử dụng một hệ thống giám sát bên ngoài (như Prometheus, Datadog, Dynatrace) mang lại nhiều lợi ích vì bạn có thể sử dụng các chức năng giám sát mạnh mẽ mà không cần phải tự mình xây dựng chúng.</p>
                    <h4 class="font-semibold text-lg mb-2">Các hệ thống này thường cung cấp:</h4>
                    <ul class="list-disc list-inside mb-4 space-y-1">
                        <li><strong>Lưu trữ bền vững</strong>: Lưu trữ dữ liệu metrics trong thời gian dài.</li>
                        <li><strong>Thu thập dữ liệu hiệu quả</strong>: Khả năng xử lý lượng lớn dữ liệu từ nhiều nguồn.</li>
                        <li><strong>Truy vấn dữ liệu và Trực quan hóa</strong>: Ngôn ngữ truy vấn mạnh mẽ và khả năng tạo biểu đồ/dashboard.</li>
                        <li><strong>Hệ thống cảnh báo (Alerting)</strong> có thể cấu hình.</li>
                    </ul>
                    <p>Spring Actuator tích hợp liền mạch với các hệ thống này thông qua <strong>Micrometer</strong>. Để tích hợp, bạn chỉ cần thêm dependency của registry tương ứng vào dự án của mình (ví dụ: <code>micrometer-registry-prometheus</code> để tích hợp với Prometheus).</p>
                `
        },
        {
            category: "Giới thiệu về Spring Boot",
            id: "springboot-springboottest",
            question: "Khi nào bạn muốn sử dụng annotation <code>@SpringBootTest</code>?",
            content: `
                    <p class="mb-4">Bạn nên sử dụng annotation <code>@SpringBootTest</code> bất cứ khi nào bạn viết một <strong>bài kiểm thử tích hợp (Integration Test)</strong> cho một ứng dụng Spring Boot.</p>
                    <p class="mb-4"><code>@SpringBootTest</code> giúp việc kiểm thử sự phối hợp giữa nhiều thành phần trở nên dễ dàng bằng cách khởi động một <code>ApplicationContext</code> hoàn chỉnh (hoặc một phần của nó) cho bài kiểm thử của bạn.</p>
                    <h4 class="font-semibold text-lg mb-2">Các tính năng hữu ích:</h4>
                    <ul class="list-disc list-inside mb-4 space-y-1">
                        <li>Tự động tạo <code>ApplicationContext</code>.</li>
                        <li>Cung cấp một môi trường web cho việc kiểm thử.</li>
                        <li>Khả năng tiêm các mock bean bằng <code>@MockBean</code> và <code>@SpyBean</code>.</li>
                        <li>Tự động cấu hình cho việc kiểm thử MVC, JPA, JSON, v.v.</li>
                    </ul>
                `
        },
        {
            category: "Giới thiệu về Spring Boot",
            id: "springboot-springboottest-autoconfig",
            question: "<code>@SpringBootTest</code> tự động cấu hình những gì?",
            content: `
                    <p class="mb-4">Annotation <code>@SpringBootTest</code> tự động cấu hình môi trường cần thiết để chạy các bài kiểm thử tích hợp. Cụ thể, nó sẽ:</p>
                    <ul class="list-disc list-inside mb-4 space-y-1">
                        <li><strong>Tự động cấu hình <code>ApplicationContext</code></strong>: Tìm kiếm lớp <code>@SpringBootApplication</code> hoặc <code>@SpringBootConfiguration</code> để tải các định nghĩa bean.</li>
                        <li><strong>Tự động cấu hình các công cụ kiểm thử</strong>: Cung cấp các tiện ích và cấu hình tự động cho việc kiểm thử.</li>
                    </ul>
                    <p>Bạn có thể kiểm thử một "lát cắt" (slice) của ứng dụng thay vì toàn bộ context bằng cách sử dụng các annotation chuyên dụng hơn như <code>@WebMvcTest</code> (chỉ tầng controller), <code>@DataJpaTest</code> (chỉ tầng repository), <code>@JsonTest</code>, <code>@RestClientTest</code>.</p>
                `
        },
        {
            category: "Giới thiệu về Spring Boot",
            id: "springboot-starter-test-dependencies",
            question: "<code>spring-boot-starter-test</code> mang lại những dependency nào?",
            content: `
                    <p class="mb-4"><code>spring-boot-starter-test</code> là một starter tiện ích, nó gộp nhiều thư viện kiểm thử phổ biến nhất vào dự án của bạn với chỉ một dependency duy nhất.</p>
                    <h4 class="font-semibold text-lg mb-2">Các dependency chính bao gồm:</h4>
                    <ul class="list-disc list-inside mb-4 space-y-1">
                        <li><strong>JUnit 5</strong>: Framework kiểm thử đơn vị tiêu chuẩn.</li>
                        <li><strong>Spring Test & Spring Boot Test</strong>: Hỗ trợ tích hợp cho việc kiểm thử Spring.</li>
                        <li><strong>AssertJ</strong>: Thư viện assertion linh hoạt.</li>
                        <li><strong>Hamcrest</strong>: Thư viện cho các đối tượng "matchers".</li>
                        <li><strong>Mockito</strong>: Framework phổ biến để tạo các đối tượng giả (mock).</li>
                        <li><strong>JSONassert</strong>: Thư viện assertion cho JSON.</li>
                        <li><strong>JsonPath</strong>: Cung cấp XPath cho JSON.</li>
                    </ul>
                    <p>Việc có sẵn các thư viện này giúp bạn có thể bắt đầu viết các bài kiểm thử đa dạng (unit, integration, mock) một cách nhanh chóng.</p>
                `
        },
        {
            category: "Giới thiệu về Spring Boot",
            id: "springboot-integration-testing-web",
            question: "Làm thế nào để thực hiện kiểm thử tích hợp (integration testing) với <code>@SpringBootTest</code> cho một ứng dụng web?",
            content: `
                    <p class="mb-4">Khi kiểm thử các thành phần web (như Controller), bài kiểm thử nên thực hiện một yêu cầu HTTP thực sự và kiểm tra phản hồi HTTP nhận được. Spring Boot cung cấp hai cách chính:</p>
                    <h4 class="font-semibold text-lg mb-2">1. Sử dụng <code>MockMvc</code></h4>
                    <p class="mb-2">Mô phỏng môi trường MVC của Spring mà không cần khởi động một máy chủ web thực sự. Nhanh hơn và lý tưởng để kiểm tra logic của controller.</p>
                    <div class="code-block mb-4">
                        <button class="copy-btn"><i class="far fa-copy"></i> Copy</button>
                        <pre><code>import static org.springframework.test.web.servlet.request.MockMvcRequestBuilders.get;
import static org.springframework.test.web.servlet.result.MockMvcResultMatchers.status;
import org.springframework.boot.test.autoconfigure.web.servlet.AutoConfigureMockMvc;
import org.springframework.boot.test.context.SpringBootTest;
import org.springframework.test.web.servlet.MockMvc;

@SpringBootTest
@AutoConfigureMockMvc
public class CityControllerWebMockMvcTest {
    // ...
}</code></pre>
                    </div>
                    <h4 class="font-semibold text-lg mb-2">2. Sử dụng Container nhúng (Embedded Container)</h4>
                    <p class="mb-2">Khởi động một máy chủ web thực sự trên một cổng ngẫu nhiên. Cho phép bạn thực hiện các yêu cầu HTTP bằng <code>TestRestTemplate</code>. Đây là bài kiểm thử tích hợp toàn diện hơn.</p>
                    <div class="code-block">
                        <button class="copy-btn"><i class="far fa-copy"></i> Copy</button>
                        <pre><code>import static org.assertj.core.api.Assertions.assertThat;
import org.springframework.boot.test.context.SpringBootTest;
import org.springframework.boot.test.web.client.TestRestTemplate;
import org.springframework.boot.test.web.server.LocalServerPort;

@SpringBootTest(webEnvironment = SpringBootTest.WebEnvironment.RANDOM_PORT)
public class CityControllerWebIntegrationTest {
    // ...
}</code></pre>
                    </div>
                `
        },
        {
            category: "Giới thiệu về Spring Boot",
            id: "springboot-webmvctest",
            question: "Khi nào bạn muốn sử dụng <code>@WebMvcTest</code>? Nó tự động cấu hình những gì?",
            content: `
                    <p class="mb-4">Bạn nên sử dụng <strong><code>@WebMvcTest</code></strong> khi muốn viết các bài kiểm thử chỉ tập trung vào <strong>tầng web (web layer)</strong> của ứng dụng, chẳng hạn như các <code>Controller</code>.</p>
                    <p class="mb-4"><code>@WebMvcTest</code> sẽ chỉ tạo một <code>ApplicationContext</code> chứa các thành phần liên quan đến web, bỏ qua các thành phần khác như <code>@Service</code> hay <code>@Repository</code>. Điều này giúp bài kiểm thử nhẹ hơn và nhanh hơn. Nếu controller của bạn phụ thuộc vào các service khác, bạn cần phải <strong>giả lập (mock)</strong> chúng bằng <code>@MockBean</code>.</p>
                    <h4 class="font-semibold text-lg mb-2">Nó tự động cấu hình các thành phần sau:</h4>
                    <ul class="list-disc list-inside mb-4 space-y-1">
                        <li><strong><code>MockMvc</code></strong></li>
                        <li>Các lớp <strong><code>@Controller</code></strong>, <strong><code>@ControllerAdvice</code></strong>, <strong><code>@JsonComponent</code></strong></li>
                        <li>Các lớp <strong><code>@Converter</code></strong>, <strong><code>@Filter</code></strong>, <strong><code>@WebMvcConfigurer</code></strong></li>
                    </ul>
                `
        },
        {
            category: "Giới thiệu về Spring Boot",
            id: "springboot-mockbean-vs-mock",
            question: "Sự khác biệt giữa <code>@MockBean</code> và <code>@Mock</code> là gì?",
            content: `
                    <div class="grid md:grid-cols-2 gap-6">
                        <div class="p-4 border rounded-lg bg-white">
                            <h4 class="font-bold text-lg text-blue-700 mb-2"><code>@Mock</code> (Từ Mockito)</h4>
                            <ul class="list-disc list-inside space-y-1">
                                <li>Tạo một đối tượng giả (mock object).</li>
                                <li><strong>Không</strong> tự động tích hợp với <code>ApplicationContext</code> của Spring.</li>
                                <li>Bạn phải tự tiêm mock này vào lớp đang được kiểm thử (thường bằng <code>@InjectMocks</code>).</li>
                                <li>Chỉ hoạt động trong phạm vi của lớp kiểm thử đó (unit test).</li>
                            </ul>
                        </div>
                        <div class="p-4 border rounded-lg bg-white">
                            <h4 class="font-bold text-lg text-green-700 mb-2"><code>@MockBean</code> (Từ Spring Boot Test)</h4>
                            <ul class="list-disc list-inside space-y-1">
                                <li>Tạo một mock object của Mockito và <strong>thay thế bean thật</strong> có cùng kiểu trong <code>ApplicationContext</code> của Spring bằng mock đó.</li>
                                <li>Bất kỳ bean nào khác trong context phụ thuộc vào bean bị mock sẽ nhận được đối tượng mock này.</li>
                                <li>Hữu ích trong các bài kiểm thử tích hợp (<code>@SpringBootTest</code>, <code>@WebMvcTest</code>).</li>
                            </ul>
                        </div>
                    </div>
                    <p class="mt-4">Tóm lại, <strong><code>@MockBean</code></strong> là một công cụ mạnh mẽ của Spring Boot để thay thế bean trong toàn bộ context cho mục đích kiểm thử tích hợp, trong khi <strong><code>@Mock</code></strong> là một công cụ cơ bản của Mockito để tạo mock cho các bài kiểm thử đơn vị.</p>
                `
        },
        {
            category: "Giới thiệu về Spring Boot",
            id: "springboot-datajpatest",
            question: "Khi nào bạn muốn sử dụng <code>@DataJpaTest</code>? Nó tự động cấu hình những gì?",
            content: `
                    <p class="mb-4">Bạn nên sử dụng <strong><code>@DataJpaTest</code></strong> khi muốn viết các bài kiểm thử tích hợp chỉ tập trung vào các thành phần liên quan đến <strong>JPA</strong>, chẳng hạn như các <code>Entity</code> và <code>Repository</code>.</p>
                    <p class="mb-4"><code>@DataJpaTest</code> sẽ không tải toàn bộ ứng dụng mà chỉ tải các thành phần cần thiết cho tầng dữ liệu, giúp bài kiểm thử nhanh và gọn gàng hơn.</p>
                    <h4 class="font-semibold text-lg mb-2">Nó tự động cấu hình các thành phần sau:</h4>
                    <ul class="list-disc list-inside mb-4 space-y-1">
                        <li>Một <strong>cơ sở dữ liệu nhúng trong bộ nhớ</strong> (in-memory embedded database).</li>
                        <li>Quét và cấu hình các bean <code>@Entity</code>.</li>
                        <li>Quét và cấu hình các <strong>Spring Data Repository</strong>.</li>
                        <li>Cấu hình một <strong><code>TestEntityManager</code></strong>, một tiện ích để thao tác với các entity.</li>
                    </ul>
                    <p>Mỗi bài kiểm thử <code>@DataJpaTest</code> đều được thực hiện trong một <strong>giao dịch (transaction)</strong> và sẽ được <strong>rollback</strong> sau khi kết thúc, đảm bảo các bài kiểm thử độc lập với nhau.</p>
                `
        },
        // =================================================================
        // Spring MVC
        // =================================================================
        {
            category: "Spring MVC",
            id: "mvc-definition",
            question: "MVC là gì và ý tưởng đằng sau nó là gì?",
            content: `
                    <p class="mb-4"><strong>MVC</strong> là viết tắt của <strong>Model-View-Controller</strong>. Đây là một mẫu kiến trúc phần mềm giúp tách biệt ứng dụng thành ba thành phần chính có liên kết với nhau, giúp cho việc phát triển và bảo trì dễ dàng hơn.</p>
                    <ul class="list-disc list-inside mb-4 space-y-1">
                        <li><strong>Model</strong>: Chịu trách nhiệm quản lý dữ liệu và logic nghiệp vụ.</li>
                        <li><strong>View</strong>: Chịu trách nhiệm hiển thị dữ liệu cho người dùng.</li>
                        <li><strong>Controller</strong>: Đóng vai trò trung gian giữa Model và View, tiếp nhận yêu cầu, xử lý và quyết định View nào sẽ được dùng.</li>
                    </ul>
                    <p><strong>Ý tưởng chính</strong> của MVC là <strong>phân tách các mối quan tâm (Separation of Concerns)</strong>, giúp giảm sự phụ thuộc, tăng khả năng tái sử dụng code, dễ bảo trì và mở rộng.</p>
                `
        },
        {
            category: "Spring MVC",
            id: "dispatcherservlet",
            question: "DispatcherServlet là gì và nó được dùng để làm gì?",
            content: `
                    <p class="mb-4"><strong>DispatcherServlet</strong> là thành phần cốt lõi của Spring MVC. Nó hoạt động như một <strong>Front Controller</strong>, xử lý tất cả các yêu cầu HTTP đến ứng dụng của bạn.</p>
                    <h4 class="font-semibold text-lg mb-2">Công dụng chính:</h4>
                    <ul class="list-disc list-inside mb-4 space-y-1">
                        <li><strong>Tiếp nhận yêu cầu</strong>: Chặn tất cả các yêu cầu HTTP đến.</li>
                        <li><strong>Ủy quyền xử lý</strong>: Tìm <code>Controller</code> và phương thức phù hợp với yêu cầu (với sự trợ giúp của <code>HandlerMapping</code>).</li>
                        <li><strong>Thực thi Controller</strong>: Sử dụng <code>HandlerAdapter</code> để thực thi phương thức controller.</li>
                        <li><strong>Xử lý kết quả</strong>: Nhận kết quả từ Controller (tên View và dữ liệu Model).</li>
                        <li><strong>Render View</strong>: Sử dụng <code>ViewResolver</code> để tìm và render View, sau đó trả về phản hồi hoàn chỉnh.</li>
                    </ul>
                `
        },
        {
            category: "Spring MVC",
            id: "web-application-context",
            question: "Web application context là gì? Nó cung cấp những scope (phạm vi) bổ sung nào?",
            content: `
                    <p class="mb-4"><strong>Web Application Context</strong> là một <code>ApplicationContext</code> được mở rộng dành riêng cho các ứng dụng web. Nó kế thừa tất cả các tính năng của một <code>ApplicationContext</code> thông thường và thêm vào các tính năng liên quan đến web, đặc biệt là quyền truy cập vào <code>ServletContext</code>.</p>
                    <h4 class="font-semibold text-lg mb-2">Các scope đặc thù cho web:</h4>
                    <ul class="list-disc list-inside mb-4 space-y-1">
                        <li><strong>Request Scope (<code>@RequestScope</code>)</strong>: Một instance bean mới cho mỗi yêu cầu HTTP.</li>
                        <li><strong>Session Scope (<code>@SessionScope</code>)</strong>: Một instance bean mới cho mỗi phiên làm việc (HTTP Session).</li>
                        <li><strong>Application Scope (<code>@ApplicationScope</code>)</strong>: Chỉ một instance bean duy nhất cho toàn bộ vòng đời của <code>ServletContext</code>.</li>
                        <li><strong>WebSocket Scope</strong>: Bean được tạo ra cho vòng đời của một phiên WebSocket.</li>
                    </ul>
                `
        },
        {
            category: "Spring MVC",
            id: "controller-annotation",
            question: "Annotation <code>@Controller</code> được dùng để làm gì?",
            content: `
                    <p class="mb-4">Annotation <strong><code>@Controller</code></strong> được dùng để đánh dấu một lớp Java là một <strong>Controller</strong> trong kiến trúc MVC của Spring.</p>
                    <p>Khi Spring quét các lớp trong ứng dụng, nó sẽ phát hiện các lớp được đánh dấu bằng <code>@Controller</code> và đăng ký chúng như những bean có khả năng xử lý các yêu cầu web. <code>@Controller</code> là một chuyên biệt hóa của annotation <code>@Component</code>.</p>
                    <p>Các phương thức bên trong một lớp <code>@Controller</code> thường được chú thích thêm bằng các annotation ánh xạ yêu cầu như <code>@RequestMapping</code>, <code>@GetMapping</code>, <code>@PostMapping</code>, v.v.</p>
                `
        },
        {
            category: "Spring MVC",
            id: "request-mapping-flow",
            question: "Một yêu cầu đến được ánh xạ tới một controller và một phương thức như thế nào?",
            content: `
                    <p class="mb-4">Quá trình ánh xạ một yêu cầu đến một phương thức controller cụ thể được điều phối bởi <strong><code>DispatcherServlet</code></strong> và thực hiện chủ yếu bởi <strong><code>HandlerMapping</code></strong>.</p>
                    <h4 class="font-semibold text-lg mb-2">Các bước:</h4>
                    <ol class="list-decimal list-inside mb-4 space-y-1">
                        <li><strong>Yêu cầu đến <code>DispatcherServlet</code></strong>: Mọi yêu cầu đều đi qua <code>DispatcherServlet</code>.</li>
                        <li><strong><code>DispatcherServlet</code> hỏi <code>HandlerMapping</code></strong>: Tìm một "handler" (phương thức controller) phù hợp.</li>
                        <li><strong><code>HandlerMapping</code> tìm handler</strong>: Kiểm tra các annotation như <code>@RequestMapping</code> (và các biến thể) trên các lớp và phương thức.</li>
                        <li><strong>Đối chiếu tiêu chí</strong>: Dựa trên <code>path</code>, <code>method</code>, <code>params</code>, <code>headers</code>, <code>consumes</code>, <code>produces</code>.</li>
                    </ol>
                    <p>Khi một phương thức controller khớp với tất cả các tiêu chí, <code>HandlerMapping</code> sẽ trả về phương thức đó cho <code>DispatcherServlet</code> để thực thi.</p>
                `
        },
        {
            category: "Spring MVC",
            id: "requestmapping-vs-getmapping",
            question: "Sự khác biệt giữa <code>@RequestMapping</code> và <code>@GetMapping</code> là gì?",
            content: `
                    <p class="mb-4">Sự khác biệt chính là về tính chuyên dụng và sự rõ ràng:</p>
                    <ul class="list-disc list-inside mb-4 space-y-1">
                        <li><strong><code>@RequestMapping</code></strong>: Là một annotation ánh xạ chung chung, có thể được sử dụng để xử lý <strong>bất kỳ phương thức HTTP nào</strong> (GET, POST, PUT, DELETE, v.v.) thông qua thuộc tính <code>method</code>.</li>
                        <li><strong><code>@GetMapping</code></strong>: Là một annotation chuyên dụng, nó là một lối tắt cho <strong><code>@RequestMapping(method = RequestMethod.GET)</code></strong>. Nó chỉ dùng để xử lý các yêu cầu HTTP GET.</li>
                    </ul>
                    <p>Nên dùng <code>@GetMapping</code> (và các biến thể khác như <code>@PostMapping</code>, <code>@PutMapping</code>, <code>@DeleteMapping</code>, <code>@PatchMapping</code>) vì nó rõ ràng và ngắn gọn hơn.</p>
                `
        },
        {
            category: "Spring MVC",
            id: "requestparam",
            question: "<code>@RequestParam</code> được dùng để làm gì?",
            content: `
                    <p class="mb-4">Annotation <strong><code>@RequestParam</code></strong> được sử dụng để trích xuất và ràng buộc các <strong>tham số của một yêu cầu web (request parameters)</strong> vào các tham số của phương thức trong controller.</p>
                    <p>Các tham số này có thể đến từ <strong>chuỗi truy vấn (Query string)</strong> trong URL (ví dụ: <code>/search?q=spring&page=1</code>) hoặc <strong>dữ liệu từ một form</strong>.</p>
                    <h4 class="font-semibold text-lg mb-2">Các thuộc tính quan trọng:</h4>
                    <ul class="list-disc list-inside mb-4 space-y-1">
                        <li><code>name</code> (hoặc <code>value</code>): Tên của tham số trong yêu cầu.</li>
                        <li><code>required</code>: Xác định xem tham số có bắt buộc hay không (mặc định là <code>true</code>).</li>
                        <li><code>defaultValue</code>: Cung cấp một giá trị mặc định nếu tham số không được tìm thấy.</li>
                    </ul>
                `
        },
        {
            category: "Spring MVC",
            id: "requestparam-vs-pathvariable",
            question: "Sự khác biệt giữa <code>@RequestParam</code> và <code>@PathVariable</code> là gì?",
            content: `
                    <p class="mb-4">Cả hai annotation này đều dùng để trích xuất dữ liệu từ URL, nhưng chúng lấy dữ liệu từ những phần khác nhau của URL:</p>
                    <ul class="list-disc list-inside mb-4 space-y-1">
                        <li><strong><code>@PathVariable</code></strong>: Dùng để trích xuất giá trị từ các <strong>biến trong đường dẫn URI (URI template variables)</strong>, là một phần của cấu trúc đường dẫn (ví dụ: <code>/users/{id}</code>). Phù hợp để xác định một tài nguyên cụ thể.</li>
                        <li><strong><code>@RequestParam</code></strong>: Dùng để trích xuất giá trị từ các <strong>tham số trong chuỗi truy vấn (query parameters)</strong>, là các cặp <code>key=value</code> xuất hiện sau dấu <code>?</code> trong URL (ví dụ: <code>/users?id=123</code>). Phù hợp cho việc lọc, sắp xếp hoặc phân trang dữ liệu.</li>
                    </ul>
                `
        },
        {
            category: "Spring MVC",
            id: "controller-method-params",
            question: "Một số kiểu tham số cho một phương thức controller là gì?",
            content: `
                    <p class="mb-4">Các phương thức trong controller của Spring rất linh hoạt và có thể chấp nhận nhiều kiểu tham số khác nhau. Spring sẽ tự động "tiêm" (inject) các đối tượng cần thiết vào làm tham số khi phương thức được gọi.</p>
                    <h4 class="font-semibold text-lg mb-2">Một số kiểu phổ biến:</h4>
                    <ul class="list-disc list-inside mb-4 space-y-1">
                        <li><strong>Các đối tượng liên quan đến Servlet API</strong>: <code>HttpServletRequest</code>, <code>HttpServletResponse</code>, <code>HttpSession</code>.</li>
                        <li><strong>Các đối tượng của Spring</strong>: <code>Model</code>/<code>ModelMap</code> (truyền dữ liệu tới View), <code>RedirectAttributes</code>, <code>Errors</code>/<code>BindingResult</code>.</li>
                        <li><strong>Dữ liệu yêu cầu</strong>: <code>Principal</code> (thông tin người dùng), <code>HttpMethod</code>, <code>Locale</code>, <code>HttpEntity</code>.</li>
                        <li><strong>Truy cập vào Body của yêu cầu/phản hồi</strong>: <code>InputStream</code>/<code>Reader</code>, <code>OutputStream</code>/<code>Writer</code>.</li>
                    </ul>
                `
        },
        {
            category: "Spring MVC",
            id: "controller-method-annotations",
            question: "Những annotation nào khác bạn có thể sử dụng trên một tham số của phương thức controller?",
            content: `
                    <p class="mb-4">Ngoài <code>@RequestParam</code> và <code>@PathVariable</code>, có nhiều annotation khác rất hữu ích để sử dụng trên các tham số của phương thức controller:</p>
                    <ul class="list-disc list-inside mb-4 space-y-1">
                        <li><strong><code>@RequestBody</code></strong>: Ràng buộc toàn bộ <strong>body của yêu cầu HTTP</strong> vào một đối tượng (thường dùng trong RESTful API để chuyển đổi JSON/XML).</li>
                        <li><strong><code>@RequestHeader</code></strong>: Trích xuất giá trị của một <strong>header cụ thể</strong> trong yêu cầu HTTP.</li>
                        <li><strong><code>@CookieValue</code></strong>: Trích xuất giá trị của một <strong>cookie HTTP</strong>.</li>
                        <li><strong><code>@ModelAttribute</code></strong>: Ràng buộc các tham số của yêu cầu vào các thuộc tính của một đối tượng.</li>
                        <li><strong><code>@MatrixVariable</code></strong>: Trích xuất các biến từ các đoạn URI (ít phổ biến hơn).</li>
                        <li><strong><code>@RequestPart</code></strong>: Dùng để truy cập một phần của một yêu cầu <code>multipart/form-data</code> (thường dùng khi tải lên tệp).</li>
                        <li><strong><code>@SessionAttribute</code></strong>: Ràng buộc một thuộc tính đã tồn tại trong session vào một tham số.</li>
                    </ul>
                `
        },
        {
            category: "Spring MVC",
            id: "controller-method-return-types",
            question: "Một số kiểu trả về hợp lệ của một phương thức controller là gì?",
            content: `
                    <p class="mb-4">Một phương thức controller trong Spring MVC có thể trả về nhiều kiểu dữ liệu khác nhau, tùy thuộc vào mục đích của bạn là trả về một API RESTful, render một trang HTML hay xử lý bất đồng bộ.</p>
                    <h4 class="font-semibold text-lg mb-2">1. Trả về Dữ liệu (Thường dùng cho REST APIs)</h4>
                    <ul class="list-disc list-inside mb-4 space-y-1">
                        <li><strong><code>@ResponseBody</code></strong>: Ghi giá trị trả về trực tiếp vào body của response HTTP (Spring sẽ chuyển đổi đối tượng thành JSON/XML).</li>
                        <li><strong><code>ResponseEntity&lt;B&gt;</code></strong>: Cho phép kiểm soát toàn bộ response HTTP (status code, headers, body).</li>
                        <li><strong><code>HttpEntity&lt;B&gt;</code></strong>: Tương tự <code>ResponseEntity</code> nhưng không thiết lập status code.</li>
                    </ul>
                    <h4 class="font-semibold text-lg mb-2">2. Trả về View (Thường dùng cho ứng dụng Web truyền thống)</h4>
                    <ul class="list-disc list-inside mb-4 space-y-1">
                        <li><strong><code>String</code></strong>: Trả về một chuỗi là <strong>tên logic của view</strong>.</li>
                        <li><strong><code>ModelAndView</code></strong>: Một đối tượng chứa cả <strong>Model</strong> (dữ liệu) và <strong>View</strong> (tên view hoặc instance của view).</li>
                        <li><strong><code>void</code></strong>: Phương thức không trả về gì, tự xử lý response hoặc chỉ định status bằng <code>@ResponseStatus</code>.</li>
                    </ul>
                    <h4 class="font-semibold text-lg mb-2">3. Các kiểu trả về khác (Bất đồng bộ/Streaming)</h4>
                    <ul class="list-disc list-inside mb-4 space-y-1">
                        <li><strong><code>Callable&lt;V&gt;</code></strong>, <strong><code>DeferredResult&lt;V&gt;</code></strong>, <strong><code>CompletableFuture&lt;V&gt;</code></strong>: Hỗ trợ xử lý bất đồng bộ.</li>
                        <li><strong><code>ResponseBodyEmitter</code></strong>, <strong><code>SseEmitter</code></strong>, <strong><code>StreamingResponseBody</code></strong>: Dùng để gửi dữ liệu theo dòng (streaming).</li>
                    </ul>
                `
        },
        // =================================================================
        // Spring Security
        // =================================================================
        {
            category: "Spring Security",
            id: "security-auth-vs-authz",
            question: "Xác thực (Authentication) và Phân quyền (Authorization) là gì? Cái nào phải có trước?",
            content: `
                    <p class="mb-4"><strong>Xác thực (Authentication)</strong> là quá trình xác minh danh tính của người dùng ("Bạn là ai?"). Nó bao gồm việc gửi thông tin định danh và thông tin xác thực (username/password) để hệ thống kiểm tra.</p>
                    <p class="mb-4"><strong>Phân quyền (Authorization)</strong> là quá trình xác định xem một người dùng đã được xác thực có được phép truy cập tài nguyên hoặc thực hiện hành động cụ thể hay không ("Bạn được phép làm gì?"). Nó dựa trên các quy tắc kiểm soát truy cập (vai trò, quyền hạn).</p>
                    <p class="mb-4"><strong>Xác thực phải được thực hiện trước phân quyền.</strong> Bạn phải biết "bạn là ai" trước khi có thể quyết định "bạn được làm gì".</p>
                `
        },
        {
            category: "Spring Security",
            id: "security-cross-cutting-concern",
            question: "Bảo mật có phải là một mối quan tâm xuyên suốt (cross-cutting concern) không? Nó được triển khai nội bộ như thế nào?",
            content: `
                    <p class="mb-4">Đúng, <strong>bảo mật là một mối quan tâm xuyên suốt</strong>. Nó ảnh hưởng đến nhiều phần của ứng dụng nhưng không trực tiếp liên quan đến logic nghiệp vụ cốt lõi.</p>
                    <h4 class="font-semibold text-lg mb-2">Cách triển khai nội bộ:</h4>
                    <ul class="list-disc list-inside mb-4 space-y-1">
                        <li><strong>Cấp độ Web (Web Level)</strong>: Dựa trên <strong>Servlet Filters</strong> để phân tích mọi yêu cầu HTTP đến, quyết định xác thực hoặc phân quyền.</li>
                        <li><strong>Cấp độ Phương thức (Method Security Level)</strong>: Dựa trên <strong>Spring AOP</strong> để tạo proxy cho các lời gọi đối tượng, đảm bảo người dùng có quyền trước khi thực thi phương thức.</li>
                    </ul>
                `
        },
        {
            category: "Spring Security",
            id: "delegating-filter-proxy",
            question: "DelegatingFilterProxy là gì?",
            content: `
                    <p class="mb-4"><strong><code>DelegatingFilterProxy</code></strong> là một lớp nội bộ của Spring Framework, hoạt động như một <strong>proxy</strong> giữa một Servlet Filter tiêu chuẩn (được quản lý bởi Servlet Container) và một Bean do Spring quản lý (triển khai giao diện Servlet Filter).</p>
                    <p>Nó hoạt động như một <strong>cây cầu</strong> nối giữa Servlet Container (như Tomcat) và Spring Application Context, cho phép các bộ lọc bảo mật của Spring (là các bean) được tận dụng các tính năng như Dependency Injection.</p>
                `
        },
        {
            category: "Spring Security",
            id: "security-filter-chain",
            question: "Chuỗi bộ lọc bảo mật (security filter chain) là gì?",
            content: `
                    <p class="mb-4"><strong>Security Filter Chain</strong> (cụ thể là <code>SecurityFilterChain</code>) là một tập hợp các bộ lọc (Filter) do Spring quản lý, chịu trách nhiệm về việc xác thực và phân quyền.</p>
                    <p>Mỗi <code>SecurityFilterChain</code> được liên kết với một <code>RequestMatcher</code> để xác định xem chuỗi bộ lọc đó có nên được áp dụng cho một yêu cầu HTTP cụ thể hay không. Khi một yêu cầu đến, <code>FilterChainProxy</code> sẽ tìm kiếm chuỗi bộ lọc khớp và thực thi tuần tự các bộ lọc trong chuỗi đó.</p>
                `
        },
        {
            category: "Spring Security",
            id: "security-context",
            question: "Security context là gì?",
            content: `
                    <p class="mb-4"><strong><code>SecurityContext</code></strong> là một giao diện chứa thông tin bảo mật liên quan đến luồng thực thi (thread of execution) hiện tại. Về cơ bản, nó chứa đối tượng <code>Authentication</code>, đại diện cho người dùng đã được xác thực.</p>
                    <p><code>SecurityContext</code> được lưu trữ trong <strong><code>SecurityContextHolder</code></strong>, đây là thành phần cốt lõi của mô hình xác thực trong Spring Security. <code>SecurityContextHolder</code> sử dụng một chiến lược lưu trữ (mặc định là <code>MODE_THREADLOCAL</code> cho mỗi luồng yêu cầu).</p>
                    <p>Đối tượng <code>Authentication</code> bên trong <code>SecurityContext</code> chứa các thông tin quan trọng như danh tính người dùng (<code>getPrincipal()</code>), thông tin xác thực (<code>getCredentials()</code>), và các quyền (<code>getAuthorities()</code>).</p>
                `
        },
        {
            category: "Spring Security",
            id: "antmatcher-wildcard",
            question: "Mẫu <code>**</code> trong <code>antMatcher</code> hoặc <code>mvcMatcher</code> có tác dụng gì?",
            content: `
                    <p class="mb-4">Mẫu <code>**</code> trong <code>antMatcher</code> và <code>mvcMatcher</code> được sử dụng để khớp với <strong>không hoặc nhiều phân đoạn đường dẫn (path segments)</strong> cho đến cuối cùng.</p>
                    <p class="mb-2">Các quy tắc khớp mẫu (wildcard) khác:</p>
                    <ul class="list-disc list-inside mb-4 space-y-1">
                        <li><code>?</code>: Khớp với một ký tự duy nhất.</li>
                        <li><code>*</code>: Khớp với không hoặc nhiều ký tự <strong>bên trong một phân đoạn đường dẫn</strong>.</li>
                    </ul>
                    <p>Ví dụ: Cho URL <code>/departments/delete/5</code>:</p>
                    <ul class="list-disc list-inside mb-4 space-y-1">
                        <li><code>/departments/delete/*</code> - <strong>Khớp</strong> (<code>*</code> khớp với <code>5</code>)</li>
                        <li><code>/departments/delete/**</code> - <strong>Khớp</strong> (<code>**</code> khớp với <code>/5</code>)</li>
                        <li><code>/**/5</code> - <strong>Khớp</strong> (<code>**</code> khớp với <code>/departments/delete</code>)</li>
                        <li><code>/*/5</code> - <strong>Không khớp</strong> (<code>*</code> chỉ khớp với một phân đoạn)</li>
                    </ul>
                `
        },
        {
            category: "Spring Security",
            id: "mvcmatcher-vs-antmatcher",
            question: "Tại sao việc sử dụng <code>mvcMatcher</code> được khuyến khích hơn <code>antMatcher</code>?",
            content: `
                    <p class="mb-4"><code>mvcMatcher</code> được khuyến khích hơn vì nó <strong>linh hoạt và dễ sử dụng hơn</strong> khi viết các quy tắc bảo mật, giúp giảm thiểu sai sót.</p>
                    <p class="mb-4">Sự khác biệt chính và quan trọng nhất là cách chúng xử lý dấu gạch chéo (<code>/</code>) ở cuối.</p>
                    <p>Ví dụ: Cho quy tắc <code>("/employees")</code>:</p>
                    <ul class="list-disc list-inside mb-4 space-y-1">
                        <li><code>mvcMatchers("/employees")</code>: Sẽ khớp với cả <code>/employees</code> <strong>và</strong> <code>/employees/</code>.</li>
                        <li><code>antMatchers("/employees")</code>: Sẽ khớp với <code>/employees</code> nhưng <strong>không</strong> khớp với <code>/employees/</code>.</li>
                    </ul>
                    <p>Do đó, khi sử dụng <code>antMatchers</code>, rất dễ bỏ sót dấu gạch chéo cuối cùng, tạo ra một lỗ hổng bảo mật tiềm tàng. <code>mvcMatcher</code> sử dụng cơ chế khớp mẫu của Spring MVC, vốn đã được thiết kế để xử lý những trường hợp này một cách nhất quán.</p>
                `
        },
        {
            category: "Spring Security",
            id: "password-hashing-salting",
            question: "Spring Security có hỗ trợ băm mật khẩu (password hashing) không? Salting là gì?",
            content: `
                    <p class="mb-4">Có, Spring Security hỗ trợ mạnh mẽ việc băm mật khẩu thông qua giao diện <strong><code>PasswordEncoder</code></strong>. Mật khẩu không bao giờ được lưu trữ dưới dạng văn bản thuần túy. Các bộ mã hóa hiện đại như <code>bcrypt</code>, <code>pbkdf2</code>, <code>scrypt</code>, <code>argon2</code> được cung cấp sẵn.</p>
                    <h4 class="font-semibold text-lg mb-2">Salting là gì?</h4>
                    <p class="mb-4"><strong>Salting</strong> là một cơ chế bảo mật được sử dụng để chống lại các cuộc tấn công đảo ngược hàm băm (như Rainbow Tables).</p>
                    <p>Ý tưởng là trước khi băm một mật khẩu, một chuỗi byte ngẫu nhiên gọi là <strong>salt</strong> sẽ được thêm vào mật khẩu đó. Salt này sau đó được lưu trữ cùng với kết quả băm. Điều này đảm bảo rằng ngay cả khi hai người dùng có cùng một mật khẩu, giá trị băm của họ vẫn sẽ khác nhau do có salt khác nhau. Các bộ mã hóa hiện đại như <code>BCryptPasswordEncoder</code> đã tự động tích hợp việc tạo và quản lý salt.</p>
                `
        },
        {
            category: "Spring Security",
            id: "method-security-why",
            question: "Tại sao bạn cần bảo mật cấp độ phương thức (method security)?",
            content: `
                    <p class="mb-4">Bảo mật cấp độ phương thức là cần thiết khi bạn cần các <strong>quy tắc bảo mật chi tiết và chặt chẽ hơn</strong> cho ứng dụng, vượt ra ngoài việc chỉ bảo vệ dựa trên các mẫu URL (bảo mật cấp độ web).</p>
                    <p>Nó giúp áp dụng các quy tắc bảo mật trực tiếp lên <strong>tầng dịch vụ (service layer)</strong> của ứng dụng, nơi chứa logic nghiệp vụ. Điều này tạo ra một lớp bảo vệ thứ hai, sâu hơn, đảm bảo rằng ngay cả khi lớp web bị bỏ qua, logic nghiệp vụ vẫn được bảo vệ.</p>
                    <p>Spring hỗ trợ nhiều annotation cho bảo mật cấp độ phương thức như <code>@PreAuthorize</code>, <code>@PostAuthorize</code>, <code>@PreFilter</code>, <code>@PostFilter</code>, <code>@Secured</code>, <code>@RolesAllowed</code>.</p>
                `
        },
        {
            category: "Spring Security",
            id: "preauthorize-vs-rolesallowed",
            question: "Annotation <code>@PreAuthorize</code> và <code>@RolesAllowed</code> làm gì? Sự khác biệt giữa chúng là gì?",
            content: `
                    <p class="mb-4">Cả hai đều là các annotation bảo mật cấp độ phương thức, được đánh giá <strong>trước khi</strong> một phương thức được thực thi để kiểm tra quyền.</p>
                    <ul class="list-disc list-inside mb-4 space-y-1">
                        <li><strong><code>@RolesAllowed</code></strong>: Là một phần của tiêu chuẩn JSR-250. Chỉ cho phép bạn chỉ định một <strong>danh sách các vai trò (roles)</strong> mà người dùng phải có. Cách sử dụng đơn giản, chỉ để kiểm tra vai trò. Cần kích hoạt bằng <code>@EnableGlobalMethodSecurity(jsr250Enabled = true)</code>.</li>
                        <li><strong><code>@PreAuthorize</code></strong>: Cho phép bạn chỉ định các điều kiện bảo mật bằng cách sử dụng <strong>Ngôn ngữ Biểu thức Spring (SpEL)</strong>. Mạnh mẽ và linh hoạt hơn nhiều, cho phép viết các logic phức tạp (kiểm tra vai trò, trạng thái xác thực, tham số phương thức, so sánh danh tính). Cần kích hoạt bằng <code>@EnableGlobalMethodSecurity(prePostEnabled = true)</code>.</li>
                    </ul>
                    <p><strong>Sự khác biệt chính</strong>: <code>@RolesAllowed</code> chỉ dùng để kiểm tra vai trò đơn giản, trong khi <code>@PreAuthorize</code> cho phép bạn viết các quy tắc bảo mật phức tạp và động bằng SpEL.</p>
                `
        },
        {
            category: "Spring Security",
            id: "preauthorize-rolesallowed-implementation",
            question: "Annotation <code>@PreAuthorized</code> và <code>@RolesAllowed</code> được triển khai như thế nào?",
            content: `
                    <p class="mb-4">Các annotation <code>@PreAuthorized</code> và <code>@RolesAllowed</code> được triển khai bằng cách sử dụng <strong>Spring AOP (Lập trình hướng khía cạnh)</strong> và các <strong><code>AccessDecisionVoter</code></strong>.</p>
                    <h4 class="font-semibold text-lg mb-2">Luồng hoạt động:</h4>
                    <ol class="list-decimal list-inside mb-4 space-y-1">
                        <li><strong>Spring AOP</strong> tạo ra một proxy xung quanh các bean được bảo vệ.</li>
                        <li>Khi một phương thức được bảo vệ được gọi, một <code>MethodSecurityInterceptor</code> sẽ chặn lời gọi này.</li>
                        <li><code>MethodSecurityInterceptor</code> sau đó gọi một <code>AccessDecisionManager</code>.</li>
                        <li><code>AccessDecisionManager</code> sẽ hỏi một hoặc nhiều <code>AccessDecisionVoter</code> để "bỏ phiếu" quyết định quyền truy cập.</li>
                    </ol>
                    <p>Mỗi loại annotation được xử lý bởi một <code>AccessDecisionVoter</code> cụ thể (ví dụ: <code>@RolesAllowed</code> bởi <code>Jsr250Voter</code>, <code>@PreAuthorize</code> bởi <code>PreInvocationAuthorizationAdviceVoter</code>).</p>
                `
        },
        {
            category: "Spring Security",
            id: "spel-in-security-annotations",
            question: "Trong annotation bảo mật nào bạn được phép sử dụng SpEL?",
            content: `
                    <p class="mb-4">Bạn được phép sử dụng <strong>SpEL (Spring Expression Language)</strong> trong các annotation bảo mật sau đây của Spring Security:</p>
                    <ul class="list-disc list-inside mb-4 space-y-1">
                        <li><strong><code>@PreAuthorize</code></strong>: Kiểm tra trước khi thực thi phương thức.</li>
                        <li><strong><code>@PostAuthorize</code></strong>: Kiểm tra sau khi thực thi phương thức (có thể truy cập kết quả trả về).</li>
                        <li><strong><code>@PreFilter</code></strong>: Lọc các đối số đầu vào dạng Collection hoặc mảng.</li>
                        <li><strong><code>@PostFilter</code></strong>: Lọc kết quả trả về dạng Collection hoặc mảng.</li>
                    </ul>
                    <p>SpEL cho phép bạn viết các biểu thức bảo mật phức tạp và động, bao gồm kiểm tra vai trò, trạng thái xác thực, truy cập tham số phương thức, và so sánh danh tính người dùng.</p>
                `
        },
        // =================================================================
        // Spring REST
        // =================================================================
        {
            category: "Spring REST",
            id: "rest-what-is",
            question: "REST là viết tắt của từ gì?",
            content: "<p class=\"mb-4\"><strong>REST</strong> là viết tắt của <strong>REpresentational State Transfer</strong> (Truyền tải trạng thái đại diện).</p><p class=\"mb-4\">Đây là một kiểu kiến trúc để thiết kế các ứng dụng phân tán. Trong kiến trúc REST, hệ thống yêu cầu (client) sẽ truy cập và thao tác trên các <strong>biểu diễn văn bản (textual representations)</strong> của tài nguyên web bằng cách sử dụng một tập hợp các <strong>thao tác phi trạng thái (stateless operations)</strong> được xác định trước.</p><p class=\"mb-4\">Các tài nguyên web này được cung cấp thông qua URI (Uniform Resource Identifiers - Định danh tài nguyên đồng nhất) và thường được truy cập hoặc sửa đổi qua các phương thức HTTP. Hầu hết các dịch vụ REST sử dụng HTTP làm giao thức ứng dụng và JSON làm định dạng dữ liệu.</p><p class=\"mb-4\">Việc tuân thủ các ràng buộc của REST mang lại các thuộc tính phi chức năng quan trọng cho hệ thống như hiệu suất (performance), khả năng mở rộng (scalability), tính đơn giản (simplicity), và độ tin cậy (reliability).</p><h4 class=\"font-semibold text-lg mb-2\">Các ràng buộc chính của REST bao gồm:</h4><ul class=\"list-disc list-inside mb-4 space-y-1\"><li>Kiến trúc Client-Server</li><li>Phi trạng thái (Statelessness)</li><li>Khả năng lưu trữ đệm (Cacheability)</li><li>Giao diện đồng nhất (Uniform interface)</li><li>Hệ thống phân lớp (Layered system)</li></ul>"
        },
        {
            category: "Spring REST",
            id: "rest-resource",
            question: "Resource (Tài nguyên) là gì?",
            content: "<p class=\"mb-4\"><strong>Resource (Tài nguyên)</strong> là một thông tin có tên, có thể truy cập được thông qua một URI. Nó có thể là bất cứ thứ gì: một tài liệu, hình ảnh, video, tệp văn bản, hoặc một đối tượng dữ liệu (ví dụ: một khách hàng, một sản phẩm).</p><p class=\"mb-4\">REST sử dụng nhiều định dạng khác nhau để biểu diễn tài nguyên, và client có thể chỉ định định dạng mà mình mong muốn nhận được, ví dụ như <strong>JSON, XML, Text, HTML</strong>, thông qua HTTP header <code>Accept</code>.</p><p class=\"mb-4\">Một tài nguyên có thể được cung cấp dưới dạng một đối tượng đơn lẻ (single resource) hoặc một tập hợp (collection of resources). Các tài nguyên cũng có thể có mối quan hệ với nhau, ví dụ như một khách hàng \"chứa\" nhiều địa chỉ.</p>"
        },
        {
            category: "Spring REST",
            id: "rest-crud",
            question: "CRUD có nghĩa là gì?",
            content: "<p class=\"mb-4\"><strong>CRUD</strong> là từ viết tắt của bốn hoạt động cơ bản trong việc quản lý dữ liệu:</p><ul class=\"list-disc list-inside mb-4 space-y-1\"><li><strong>C</strong>reate (Tạo mới)</li><li><strong>R</strong>ead (Đọc/Truy xuất)</li><li><strong>U</strong>pdate (Cập nhật)</li><li><strong>D</strong>elete (Xóa)</li></ul><p class=\"mb-4\">Trong REST API sử dụng giao thức HTTP, các hoạt động CRUD này thường được ánh xạ tới các phương thức HTTP tiêu chuẩn như sau:</p><ul class=\"list-disc list-inside mb-4 space-y-1\"><li><strong>Create</strong> → <code>POST</code> / <code>PUT</code></li><li><strong>Read</strong> → <code>GET</code></li><li><strong>Update</strong> → <code>PUT</code> / <code>PATCH</code></li><li><strong>Delete</strong> → <code>DELETE</code></li></ul>"
        },
        {
            category: "Spring REST",
            id: "rest-security",
            question: "REST có an toàn không? Bạn có thể làm gì để bảo mật nó?",
            content: "<p class=\"mb-4\">Bản thân REST, với tư cách là một kiểu kiến trúc, <strong>không tự nó cung cấp bất kỳ cơ chế bảo mật nào</strong>. Do đó, mặc định REST không an toàn.</p><p class=\"mb-4\">Tuy nhiên, vì REST khuyến khích cách tiếp cận phân lớp (layered approach), bảo mật có thể được thêm vào như một lớp riêng biệt trong hệ thống. Trong hệ sinh thái Spring, điều này có thể dễ dàng đạt được bằng cách sử dụng module <strong>Spring Security</strong>.</p><h4 class=\"font-semibold text-lg mb-2\">Để bảo mật một REST API, bạn có thể thực hiện các biện pháp sau:</h4><ol class=\"list-decimal list-inside mb-4 space-y-1\"><li><strong>Sử dụng HTTPS</strong>: Mã hóa lưu lượng dữ liệu truyền đi giữa client và server để chống lại việc nghe lén.</li><li><strong>Xác thực (Authentication)</strong>: Xác định danh tính của người dùng (Basic Authentication, OAuth 2.0, JWT).</li><li><strong>Phân quyền (Authorization)</strong>: Xác định những gì một người dùng đã được xác thực được phép làm (sử dụng vai trò).</li></ol>"
        },
        {
            category: "Spring REST",
            id: "rest-scalability-interoperability",
            question: "REST có khả năng mở rộng và/hoặc tương tác không?",
            content: "<p class=\"mb-4\"><strong>Có</strong>, REST có cả hai đặc tính này.</p><h4 class=\"font-semibold text-lg mb-2\">Khả năng mở rộng (Scalability)</h4><p class=\"mb-4\">Khả năng mở rộng của dịch vụ RESTful đến từ các đặc điểm thiết kế sau:</p><ul class=\"list-disc list-inside mb-4 space-y-1\"><li><strong>Tính phi trạng thái (Statelessness)</strong>: Mỗi request từ client phải chứa tất cả thông tin cần thiết, cho phép dễ dàng phân phối request đến bất kỳ node server nào.</li><li><strong>Hệ thống phân lớp (Layered Approach)</strong>: Có thể thêm các thành phần trung gian mà không cần thay đổi client.</li><li><strong>Khả năng lưu trữ đệm (Cacheability)</strong>: Các phản hồi có thể được lưu vào bộ đệm để giảm tải cho server.</li></ul><h4 class=\"font-semibold text-lg mb-2\">Khả năng tương tác (Interoperability)</h4><p class=\"mb-4\">Dịch vụ REST có khả năng tương tác cao vì:</p><ul class=\"list-disc list-inside mb-4 space-y-1\"><li><strong>Dựa trên các tiêu chuẩn mở</strong>: Việc truy cập tài nguyên qua URI và sử dụng các phương thức HTTP là tiêu chuẩn.</li><li><strong>Hỗ trợ nhiều định dạng dữ liệu</strong>: Dữ liệu có thể được gửi và nhận ở nhiều định dạng (JSON, XML).</li><li><strong>Sử dụng các phương thức chuẩn</strong>: Các hoạt động CRUD được xử lý bằng các phương thức HTTP chuẩn.</li></ul>"
        },
        {
            category: "Spring REST",
            id: "rest-http-methods",
            question: "REST sử dụng các phương thức HTTP nào?",
            content: "<p class=\"mb-4\">REST sử dụng các phương thức HTTP tiêu chuẩn để thực hiện các hoạt động trên tài nguyên. Các phương thức chính bao gồm:</p><ul class=\"list-disc list-inside mb-4 space-y-1\"><li><strong><code>GET</code></strong>: Dùng để <strong>đọc</strong> (Read) hoặc truy xuất một tài nguyên. Hoạt động an toàn và không thay đổi trạng thái.</li><li><strong><code>POST</code></strong>: Thường dùng để <strong>tạo mới</strong> (Create) một tài nguyên hoặc kích hoạt một hành động.</li><li><strong><code>PUT</code></strong>: Dùng để <strong>tạo mới</strong> (Create) hoặc <strong>cập nhật toàn bộ</strong> (Update) một tài nguyên đã tồn tại.</li><li><strong><code>PATCH</code></strong>: Dùng để <strong>cập nhật một phần</strong> (Partial Update) của một tài nguyên đã tồn tại.</li><li><strong><code>DELETE</code></strong>: Dùng để <strong>xóa</strong> (Delete) một tài nguyên đã tồn tại.</li></ul>"
        },
        {
            category: "Spring REST",
            id: "http-message-converter",
            question: "HttpMessageConverter là gì?",
            content: "<p class=\"mb-4\"><code>HttpMessageConverter</code> là một interface cốt lõi trong Spring Framework, có nhiệm vụ <strong>chuyển đổi dữ liệu</strong> giữa đối tượng Java và nội dung của một HTTP request/response body.</p><p class=\"mb-4\">Nó hoạt động \"phía sau hậu trường\" để thực hiện các công việc sau:</p><ul class=\"list-disc list-inside mb-4 space-y-1\"><li><strong>Đọc request</strong>: Chuyển đổi nội dung request body (JSON, XML) thành một đối tượng Java (cho <code>@RequestBody</code>).</li><li><strong>Ghi response</strong>: Chuyển đổi đối tượng Java thành một định dạng cụ thể (JSON) và ghi vào HTTP response body (cho <code>@ResponseBody</code> hoặc <code>@RestController</code>).</li></ul><p class=\"mb-4\">Spring sẽ tự động chọn <code>HttpMessageConverter</code> phù hợp dựa trên <code>Content-Type</code> và <code>Accept</code> headers của request, cũng như loại đối tượng cần chuyển đổi.</p>"
        },
        {
            category: "Spring REST",
            id: "rest-stateless",
            question: "REST có thường là stateless (phi trạng thái) không?",
            content: "<p class=\"mb-4\"><strong>Có, statelessness (tính phi trạng thái) là một trong những ràng buộc cơ bản và quan trọng nhất của kiến trúc REST.</strong></p><p class=\"mb-4\">Điều này có nghĩa là server <strong>không lưu trữ bất kỳ thông tin ngữ cảnh nào về client</strong> giữa các request. Mỗi request từ client phải chứa tất cả thông tin cần thiết để server có thể hiểu và xử lý nó một cách độc lập, mà không cần dựa vào bất kỳ request nào trước đó.</p><p class=\"mb-4\">Nếu cần duy trì một trạng thái nào đó (ví dụ: thông tin phiên đăng nhập của người dùng), thì chính client phải chịu trách nhiệm gửi trạng thái đó trong mỗi request (ví dụ: gửi một token xác thực trong header <code>Authorization</code>). Server không được phép lưu trữ trạng thái này, ví dụ như trong <code>HttpSession</code>.</p><p class=\"mb-4\"><strong>Lợi ích chính của tính phi trạng thái là khả năng mở rộng (scalability)</strong>, vì bất kỳ request nào cũng có thể được xử lý bởi bất kỳ server nào, giúp việc cân bằng tải trở nên hiệu quả.</p>"
        },
        {
            category: "Spring REST",
            id: "request-mapping-rest",
            question: "@RequestMapping làm gì?",
            content: "<p class=\"mb-4\"><code>@RequestMapping</code> là một annotation cực kỳ quan trọng và linh hoạt trong Spring MVC, dùng để <strong>ánh xạ (map) các web request tới các phương thức xử lý (handler methods)</strong> cụ thể trong controller.</p><p class=\"mb-4\">Nó có thể được sử dụng ở cả cấp độ lớp (class-level) và cấp độ phương thức (method-level).</p><ul class=\"list-disc list-inside mb-4 space-y-1\"><li><strong>Ở cấp độ lớp</strong>: Nó tạo ra một tiền tố URI chung cho tất cả các ánh xạ bên trong controller đó.</li><li><strong>Ở cấp độ phương thức</strong>: Nó xác định URI cụ thể và các điều kiện khác cho phương thức xử lý đó.</li></ul><p class=\"mb-4\"><code>@RequestMapping</code> cho phép bạn lọc request dựa trên các tiêu chí như <code>path</code> (URI), <code>method</code> (HTTP method), <code>params</code>, <code>headers</code>, <code>consumes</code>, <code>produces</code>.</p><p class=\"mb-4\">Spring cũng cung cấp các annotation rút gọn cho các phương thức HTTP phổ biến như <code>@GetMapping</code>, <code>@PostMapping</code>, v.v.</p>"
        },
        {
            category: "Spring REST",
            id: "controller-restcontroller-stereotype",
            question: "@Controller và @RestController có phải là stereotype không? Stereotype là gì?",
            content: "<p class=\"mb-4\"><strong>Có, cả <code>@Controller</code> và <code>@RestController</code> đều là các annotation stereotype.</strong></p><p class=\"mb-4\"><strong>Stereotype annotation</strong> là một annotation được dùng để đánh dấu một lớp với một \"vai trò\" (role) cụ thể trong ứng dụng. Khi Spring quét các thành phần, nó sẽ phát hiện các lớp được đánh dấu bằng stereotype, khởi tạo chúng thành các Spring bean và đưa vào Application Context để quản lý.</p><p class=\"mb-4\">Về cơ bản, stereotype cung cấp một ngữ nghĩa cho lớp, cho biết nó thực hiện chức năng gì. Các stereotype chính trong Spring bao gồm: <code>@Component</code>, <code>@Service</code>, <code>@Repository</code>, <code>@Controller</code>.</p><h4 class=\"font-semibold text-lg mb-2\">@RestController là gì?</h4><p class=\"mb-4\"><code>@RestController</code> là một stereotype đặc biệt, được giới thiệu trong Spring 4.0 để giúp việc xây dựng RESTful web services trở nên dễ dàng hơn.</p><p class=\"mb-4\">Nó là sự kết hợp của hai annotation: <strong><code>@Controller</code></strong> và <strong><code>@ResponseBody</code></strong>. Khi sử dụng <code>@RestController</code>, giá trị trả về của các phương thức sẽ tự động được tuần tự hóa (serialized) thành một định dạng như JSON hoặc XML và được ghi trực tiếp vào phần thân (body) của HTTP response.</p><p class=\"mb-4\">Nói cách khác, <code>@RestController</code> = <code>@Controller</code> + <code>@ResponseBody</code>.</p>"
        },
        {
            category: "Spring REST",
            id: "controller-vs-restcontroller",
            question: "Sự khác biệt giữa @Controller và @RestController là gì?",
            content: "<p class=\"mb-4\">Sự khác biệt chính nằm ở giá trị trả về của các phương thức xử lý (handler methods).</p><ul class=\"list-disc list-inside mb-4 space-y-1\"><li><strong><code>@Controller</code></strong>: Đây là một annotation của Spring MVC truyền thống. Nó đánh dấu một lớp là một controller, và các phương thức trong đó thường trả về một đối tượng <code>Model</code> và tên của một <code>View</code> (ví dụ: một trang HTML). Sau đó, một template engine (như Thymeleaf) sẽ sử dụng chúng để render giao diện người dùng.</li><li><strong><code>@RestController</code></strong>: Đây là một annotation chuyên dụng để xây dựng các RESTful API. Nó là sự kết hợp của <code>@Controller</code> và <code>@ResponseBody</code>. Khi sử dụng <code>@RestController</code>, giá trị trả về của các phương thức sẽ tự động được tuần tự hóa (serialized) thành một định dạng như JSON hoặc XML và được ghi trực tiếp vào phần thân (body) của HTTP response.</li></ul><p class=\"mb-4\">Về cơ bản: <code>@RestController</code> = <code>@Controller</code> + <code>@ResponseBody</code>.</p>"
        },
        {
            category: "Spring REST",
            id: "when-to-use-responsebody",
            question: "Khi nào bạn cần dùng @ResponseBody?",
            content: "<p class=\"mb-4\">Bạn cần sử dụng annotation <strong><code>@ResponseBody</code></strong> khi bạn muốn giá trị trả về của một phương thức trong controller được ghi trực tiếp vào phần thân của HTTP response. Thay vì diễn giải giá trị trả về như là tên của một view, Spring sẽ sử dụng một <code>HttpMessageConverter</code> để tuần tự hóa (serialize) giá trị đó (thường là thành JSON hoặc XML).</p><p class=\"mb-4\"><code>@ResponseBody</code> rất hữu ích khi xây dựng các backend API, chẳng hạn như REST API.</p><p class=\"mb-4\">Tuy nhiên, bạn <strong>không cần</strong> sử dụng <code>@ResponseBody</code> nếu đã sử dụng <code>@RestController</code> cho cả lớp, vì <code>@RestController</code> đã bao gồm <code>@ResponseBody</code> trong định nghĩa của nó.</p><h4 class=\"font-semibold text-lg mb-2\">Nó có thể được sử dụng ở các vị trí sau:</h4><ul class=\"list-disc list-inside mb-4 space-y-1\"><li>Trên một phương thức.</li><li>Trên một lớp (sẽ áp dụng cho tất cả các phương thức trong lớp đó).</li><li>Trên một annotation khác (như cách <code>@RestController</code> được tạo ra).</li></ul>"
        },
        {
            category: "Spring REST",
            id: "http-status-codes",
            question: "Các mã trạng thái HTTP trả về cho một hoạt động GET, POST, PUT hoặc DELETE thành công là gì?",
            content: "<p class=\"mb-4\">Dưới đây là các mã trạng thái (status codes) HTTP thường được sử dụng cho các hoạt động thành công trong một REST API:</p><ul class=\"list-disc list-inside mb-4 space-y-1\"><li><strong>GET</strong>: <strong>200 (OK)</strong>: Khi tài nguyên được tìm thấy và nội dung của nó được gửi lại thành công.</li><li><strong>POST</strong>: <ul><li><strong>201 (Created)</strong>: Khi một tài nguyên mới đã được tạo thành công.</li><li><strong>200 (OK)</strong>: Khi một quá trình xử lý được thực thi thành công nhưng không có tài nguyên mới nào được tạo.</li><li><strong>204 (No Content)</strong>: Khi một quá trình xử lý được thực thi thành công và không có nội dung nào được trả về.</li></ul></li><li><strong>PUT</strong>: <ul><li><strong>201 (Created)</strong>: Khi một tài nguyên mới được tạo bằng phương thức PUT.</li><li><strong>200 (OK)</strong>: Khi một tài nguyên đã tồn tại được cập nhật thành công.</li><li><strong>204 (No Content)</strong>: Khi một tài nguyên đã tồn tại được cập nhật thành công và không có nội dung nào được trả về.</li></ul></li><li><strong>DELETE</strong>: <strong>204 (No Content)</strong>: Khi tài nguyên đã được xóa thành công.</li></ul><p class=\"mb-4\">Đối với các hoạt động bất đồng bộ (asynchronous), mã <strong>202 (Accepted)</strong> có thể được sử dụng để cho biết yêu cầu đã được chấp nhận để xử lý.</p>"
        },
        {
            category: "Spring REST",
            id: "when-to-use-responsestatus",
            question: "Khi nào bạn cần dùng @ResponseStatus?",
            content: "<p class=\"mb-4\">Bạn cần sử dụng annotation <strong><code>@ResponseStatus</code></strong> khi muốn <strong>ghi đè (override)</strong> mã trạng thái HTTP mặc định được trả về từ một phương thức xử lý trong controller.</p><p class=\"mb-4\">Thông thường, một phương thức thành công sẽ trả về <code>200 OK</code>. <code>@ResponseStatus</code> cho phép bạn thay đổi điều này thành một mã trạng thái khác (ví dụ: <code>201 Created</code>) mà không cần sử dụng <code>ResponseEntity</code>.</p><h4 class=\"font-semibold text-lg mb-2\">Nó có thể được áp dụng tại:</h4><ul class=\"list-disc list-inside mb-4 space-y-1\"><li>Một phương thức trong controller.</li><li>Toàn bộ lớp controller.</li><li>Một lớp Exception (ngoại lệ).</li></ul><p class=\"mb-4\">Nó cho phép bạn thiết lập mã trạng thái HTTP (ví dụ: <code>HttpStatus.CREATED</code>) và một thông báo lý do (reason message) sẽ được sử dụng trong response nếu có lỗi.</p>"
        },
        {
            category: "Spring REST",
            id: "requestbody-vs-responsebody",
            question: "Bạn cần @ResponseBody ở đâu? Còn @RequestBody thì sao?",
            content: "<p class=\"mb-4\">Cả hai annotation này đều đóng vai trò quan trọng trong việc xử lý dữ liệu cho các REST API.</p><ul class=\"list-disc list-inside mb-4 space-y-1\"><li><strong><code>@RequestBody</code></strong>: <ul><li><strong>Mục đích</strong>: Dùng để <strong>liên kết (bind)</strong> phần thân của một HTTP request đến một tham số của phương thức trong controller. <code>HttpMessageConverter</code> sẽ chuyển đổi nội dung request (JSON) thành đối tượng Java.</li><li><strong>Vị trí</strong>: Chỉ có thể được sử dụng trên một <strong>tham số của phương thức</strong>.</li><li><strong>Tính năng bổ sung</strong>: Có thể kết hợp với <code>@Valid</code> để kích hoạt Bean Validation.</li></ul></li><li><strong><code>@ResponseBody</code></strong>: <ul><li><strong>Mục đích</strong>: Dùng để báo cho Spring biết rằng giá trị trả về của một phương thức nên được <strong>tuần tự hóa (serialize)</strong> và ghi trực tiếp vào phần thân của HTTP response. Nó cũng sử dụng <code>HttpMessageConverter</code>.</li><li><strong>Vị trí</strong>: Có thể được sử dụng trên một <strong>phương thức</strong>, trên một <strong>lớp</strong>, hoặc trên một <strong>annotation khác</strong>.</li><li><strong>Lưu ý</strong>: Nếu bạn sử dụng <code>@RestController</code>, bạn không cần phải thêm <code>@ResponseBody</code> nữa.</li></ul></li></ul>"
        },
        {
            category: "Spring REST",
            id: "controller-code-analysis",
            question: "Nếu bạn thấy một đoạn mã Controller ví dụ, bạn có hiểu nó đang làm gì không?",
            content: "<p class=\"mb-4\">Có, việc hiểu một đoạn mã controller trong Spring trở nên khá đơn giản nếu bạn nắm vững ý nghĩa của các annotation chính.</p><p class=\"mb-4\">Một controller điển hình cho REST API thường bao gồm các thành phần sau:</p><ol class=\"list-decimal list-inside mb-4 space-y-1\"><li><strong>Định nghĩa Controller</strong>: <ul><li><code>@RestController</code>: Đánh dấu lớp là một REST controller. Mọi giá trị trả về sẽ được tuần tự hóa.</li><li><code>@RequestMapping(\"/api\")</code>: Đặt một đường dẫn gốc (prefix) cho tất cả các endpoint trong controller này.</li></ul></li><li><strong>Phương thức xử lý (Handler Method)</strong>: <ul><li><code>@GetMapping</code>, <code>@PostMapping</code>, v.v.: Ánh xạ các request HTTP đến các phương thức cụ thể.</li><li><code>@PathVariable</code>: Trích xuất một giá trị từ URI.</li><li><code>@RequestParam</code>: Lấy một tham số từ chuỗi truy vấn.</li><li><code>@RequestBody</code>: Lấy toàn bộ phần thân (body) của request và chuyển đổi thành đối tượng Java.</li><li><code>@Valid</code>: Kích hoạt xác thực (validation) cho đối tượng.</li></ul></li><li><strong>Xử lý Response</strong>: <ul><li><code>ResponseEntity</code>: Kiểm soát toàn bộ HTTP response (mã trạng thái, headers, body).</li><li><code>@ResponseStatus</code>: Tùy chỉnh mã trạng thái HTTP trả về.</li></ul></li><li><strong>Xử lý lỗi</strong>: <ul><li><code>@ExceptionHandler</code>: Định nghĩa phương thức để xử lý các exception cụ thể.</li><li><code>@ControllerAdvice</code>: Định nghĩa các trình xử lý lỗi toàn cục.</li></ul></li></ol>"
        },
        {
            category: "Spring REST",
            id: "spring-mvc-classpath",
            question: "Bạn có cần Spring MVC trong classpath không?",
            content: "<p class=\"mb-4\"><strong>Có, bạn cần có Spring MVC trong classpath để một REST API hoạt động chính xác.</strong></p><p class=\"mb-4\">Mặc dù các annotation chính bạn sử dụng để xây dựng REST API (như <code>@RestController</code>, <code>@RequestMapping</code>, <code>@GetMapping</code>, <code>@RequestBody</code>) nằm trong module <strong><code>spring-web</code></strong>, nhưng module này không phụ thuộc vào <code>spring-webmvc</code>.</p><p class=\"mb-4\">Tuy nhiên, để một request có thể được định tuyến và xử lý bởi một <code>@RestController</code>, cần phải có <strong><code>DispatcherServlet</code></strong> được khởi tạo. <code>DispatcherServlet</code> chính là \"trái tim\" của Spring MVC, chịu trách nhiệm nhận tất cả các request đến và điều phối chúng đến các controller phù hợp. <code>DispatcherServlet</code> nằm trong module <strong><code>spring-webmvc</code></strong>.</p><p class=\"mb-4\">Do đó, <code>spring-webmvc</code> là một phụ thuộc bắt buộc lúc chạy (runtime), mặc dù không cần thiết lúc biên dịch (compile time).</p><p class=\"mb-4\">Khi bạn sử dụng Spring Boot, việc này trở nên vô cùng đơn giản. Khi bạn thêm starter <code>spring-boot-starter-web</code> vào tệp <code>pom.xml</code>, nó sẽ tự động kéo cả <code>spring-web</code> và <code>spring-webmvc</code> vào dưới dạng các phụ thuộc bắc cầu (transitive dependencies), vì vậy bạn không cần phải khai báo chúng một cách tường minh.</p>"
        },
        {
            category: "Spring REST",
            id: "spring-boot-starter-rest-app",
            question: "Bạn sẽ sử dụng Spring Boot starter nào cho một ứng dụng Spring REST?",
            content: "<p class=\"mb-4\">Để tạo một ứng dụng Spring REST, bạn nên sử dụng <strong><code>spring-boot-starter-web</code></strong>.</p><p class=\"mb-4\">Đây là starter tiêu chuẩn cho việc xây dựng các ứng dụng web, bao gồm cả các ứng dụng RESTful, sử dụng Spring MVC. Theo mặc định, nó sử dụng Tomcat làm server nhúng.</p><p class=\"mb-4\">Việc thêm starter này vào dự án của bạn sẽ tự động cấu hình tất cả các phụ thuộc cần thiết để bạn có thể bắt đầu xây dựng các endpoint ngay lập tức.</p><h4 class=\"font-semibold text-lg mb-2\">Ví dụ trong <code>pom.xml</code>:</h4><div class=\"code-block\"><button class=\"copy-btn\"><i class=\"far fa-copy\"></i> Copy</button><pre><code>&lt;dependency&gt;    &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;    &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt;&lt;/dependency&gt;</code></pre></div><p class=\"mb-4\">Starter này sẽ tự động thêm các phụ thuộc quan trọng sau vào classpath của bạn:</p><ul class=\"list-disc list-inside mb-4 space-y-1\"><li><strong><code>spring-web</code></strong>: Cung cấp các tích hợp web cơ bản.</li><li><strong><code>spring-webmvc</code></strong>: Cung cấp framework Spring MVC cho việc xử lý request, bao gồm cả các REST API.</li><li><strong><code>spring-boot-starter-json</code></strong>: Cung cấp thư viện Jackson để xử lý việc chuyển đổi đối tượng Java sang JSON và ngược lại.</li><li><strong><code>spring-boot-starter-tomcat</code></strong>: Cung cấp một server Tomcat nhúng để bạn có thể chạy ứng dụng của mình mà không cần triển khai lên một server riêng biệt.</li></ul>"
        },
        {
            category: "Spring REST",
            id: "rest-template-advantages",
            question: "Ưu điểm của RestTemplate là gì?",
            content: "<p class=\"mb-4\"><code>RestTemplate</code> là một client HTTP <strong>đồng bộ (synchronous)</strong> của Spring, được dùng để thực hiện các HTTP request từ một ứng dụng Spring đến các dịch vụ khác.</p><h4 class=\"font-semibold text-lg mb-2\">Các ưu điểm chính của <code>RestTemplate</code> bao gồm:</h4><ul class=\"list-disc list-inside mb-4 space-y-1\"><li><strong>Đơn giản (Simplicity)</strong>: Cung cấp một API cấp cao, dễ sử dụng, che giấu sự phức tạp của các thư viện HTTP client bên dưới.</li><li><strong>Tự động chuyển đổi đối tượng</strong>: Tự động tuần tự hóa/giải tuần tự hóa đối tượng Java sang/từ JSON/XML.</li><li><strong>Hỗ trợ các phương thức HTTP phổ biến</strong>: Cung cấp các phương thức tiện lợi cho GET, POST, PUT, DELETE, PATCH.</li><li><strong>Hỗ trợ URI Templates</strong>: Dễ dàng truyền tham số vào URI.</li><li><strong>Linh hoạt và có thể mở rộng</strong>: Cho phép tùy chỉnh việc xử lý lỗi và đăng ký các <code>HttpMessageConverters</code> bổ sung.</li></ul><p class=\"mb-4\"><strong>Lưu ý quan trọng</strong>: Kể từ Spring 5, <code>RestTemplate</code> đã được đưa vào chế độ bảo trì (maintenance mode). <code>WebClient</code>, một client HTTP không đồng bộ (non-blocking) và phản ứng (reactive), là sự lựa chọn được khuyến nghị cho các ứng dụng mới.</p>"
        },
        {
            category: "Spring REST",
            id: "rest-template-understanding",
            question: "Nếu bạn thấy một ví dụ sử dụng RestTemplate, bạn có hiểu nó đang làm gì không?",
            content: "<p class=\"mb-4\">Có, <code>RestTemplate</code> có một API khá trực quan và dễ hiểu, được tổ chức xoay quanh các phương thức HTTP.</p><p class=\"mb-4\">Khi xem một ví dụ sử dụng <code>RestTemplate</code>, bạn cần chú ý đến tên của phương thức được gọi, vì nó thường cho biết:</p><ol class=\"list-decimal list-inside mb-4 space-y-1\"><li><strong>Phương thức HTTP</strong> nào đang được sử dụng (GET, POST, v.v.).</li><li><strong>Loại dữ liệu</strong> nào được mong đợi trả về.</li></ol><p class=\"mb-4\"><code>RestTemplate</code> có thể trả về kết quả theo hai cách chính:</p><ul class=\"list-disc list-inside mb-4 space-y-1\"><li><strong>Dưới dạng một đối tượng (Object)</strong>: Các phương thức có tên chứa <code>forObject</code> (ví dụ: <code>getForObject</code>, <code>postForObject</code>) sẽ trực tiếp trả về đối tượng đã được giải tuần tự hóa từ response body.</li><li><strong>Dưới dạng một <code>ResponseEntity</code></strong>: Các phương thức có tên chứa <code>forEntity</code> (ví dụ: <code>getForEntity</code>, <code>postForEntity</code>) sẽ trả về một đối tượng <code>ResponseEntity</code>. Đối tượng này bao bọc cả response body, mã trạng thái HTTP, và các HTTP headers.</li></ul><p class=\"mb-4\">Dưới đây là một số phương thức phổ biến được phân loại theo HTTP verb:</p><ul class=\"list-disc list-inside mb-4 space-y-1\"><li><strong>GET</strong>: <code>getForObject()</code>, <code>getForEntity()</code></li><li><strong>POST</strong>: <code>postForObject()</code>, <code>postForEntity()</code>, <code>postForLocation()</code></li><li><strong>PUT</strong>: <code>put()</code></li><li><strong>DELETE</strong>: <code>delete()</code></li><li><strong>Linh hoạt nhất</strong>: <code>exchange()</code> cho phép bạn chỉ định mọi thứ một cách tường minh và trả về một <code>ResponseEntity</code>.</li></ul>"
        },
        // =================================================================
        // Spring Test
        // =================================================================
        {
            category: "Spring Test",
            id: "spring-in-unit-test",
            question: "Bạn có sử dụng Spring trong unit test không?",
            content: `
                    <p class="mb-4">Thông thường, Spring Framework <strong>không được sử dụng</strong> trong các bài kiểm thử đơn vị (unit test). Unit test được thiết kế để kiểm thử một đơn vị chức năng (thường là một lớp) một cách cô lập. Điều này có nghĩa là các thành phần phụ thuộc (collaborators) của lớp đó cần được giả lập (mock), và không cần khởi động một môi trường hay một IoC/DI container nào.</p>
                    <p class="mb-4">Tuy nhiên, Spring cung cấp một số lớp tiện ích để hỗ trợ việc viết unit test trong các trường hợp đặc biệt:</p>
                    <ul class="list-disc list-inside mb-4 space-y-1">
                        <li><strong><code>ReflectionTestUtils</code></strong>: Dùng để thiết lập các trường (field) private, hữu ích khi bạn cần tiêm (inject) các mock một cách thủ công mà không có container.</li>
                        <li><strong>Các lớp Mock</strong>: Spring cung cấp các đối tượng mock cho Servlet API (<code>MockHttpServletRequest</code>), Environment (<code>MockEnvironment</code>), và nhiều thứ khác để bạn có thể kiểm thử các thành phần phụ thuộc vào chúng mà không cần môi trường thực.</li>
                    </ul>
                `
        },
        {
            category: "Spring Test",
            id: "test-types-using-spring",
            question: "Loại test nào thường sử dụng Spring?",
            content: `
                    <p class="mb-4"><strong>Kiểm thử tích hợp (Integration Tests)</strong> là loại test thường sử dụng Spring nhất.</p>
                    <p class="mb-4">Lý do là vì ở cấp độ kiểm thử tích hợp, mục tiêu của chúng ta là kiểm tra sự phối hợp của nhiều thành phần với nhau trong một môi trường gần giống với môi trường production. Để làm được điều này, chúng ta cần một IoC/DI container để khởi tạo, liên kết (wire) và quản lý vòng đời của các đối tượng (bean). Spring Framework làm rất tốt việc này.</p>
                    <p class="mb-4">Spring cung cấp sự hỗ trợ tuyệt vời cho kiểm thử tích hợp, với các mục tiêu chính:</p>
                    <ul class="list-disc list-inside mb-4 space-y-1">
                        <li>Quản lý và cache Spring IoC container giữa các bài test để tăng tốc độ thực thi.</li>
                        <li>Hỗ trợ tiêm phụ thuộc (Dependency Injection) vào các lớp test bằng các annotation như <code>@Autowired</code>.</li>
                        <li>Quản lý giao dịch (transaction) để đảm bảo các bài test không ảnh hưởng đến dữ liệu của nhau, thường bằng cách tự động rollback sau mỗi test.</li>
                    </ul>
                `
        },
        {
            category: "Spring Test",
            id: "shared-application-context",
            question: "Làm thế nào để tạo một application context dùng chung trong một integration test JUnit?",
            content: `
                    <p class="mb-4">Việc chia sẻ một <code>ApplicationContext</code> giữa các bài test tích hợp là một kỹ thuật quan trọng để tăng tốc độ thực thi, vì việc khởi tạo context tốn nhiều thời gian.</p>
                    <p class="mb-4">Spring Test Context Framework sẽ tự động <strong>cache và tái sử dụng</strong> các context theo mặc định. Một context sẽ được dùng chung giữa các bài test miễn là cấu hình của chúng hoàn toàn giống nhau. Cấu hình này bao gồm các thuộc tính trong <code>@ContextConfiguration</code> (như <code>classes</code>, <code>locations</code>), <code>@ActiveProfiles</code>, <code>@TestPropertySource</code>, và các annotation khác.</p>
                    <p class="mb-4">Để chia sẻ định nghĩa context một cách nhất quán giữa các lớp test, bạn có thể:</p>
                    <ul class="list-disc list-inside mb-4 space-y-1">
                        <li>Tạo một <strong>lớp test cơ sở (base class)</strong> chứa các annotation cấu hình chung (<code>@SpringBootTest</code>, <code>@ContextConfiguration</code>, <code>@ActiveProfiles</code>). Các lớp test khác sẽ kế thừa từ lớp này.</li>
                        <li>Tạo một <strong>annotation tùy chỉnh (custom annotation)</strong> bao gồm các annotation cấu hình và sử dụng nó trên các lớp test.</li>
                    </ul>
                    <p>Để buộc Spring phải tạo một context mới và không dùng lại từ cache, bạn có thể sử dụng annotation <code>@DirtiesContext</code>.</p>
                `
        },
        {
            category: "Spring Test",
            id: "transactional-in-testing",
            question: "Khi nào và ở đâu bạn sử dụng <code>@Transactional</code> trong testing?",
            content: `
                    <p class="mb-4">Annotation <code>@Transactional</code> được sử dụng trong các bài test tích hợp khi bạn cần thực thi các đoạn mã có khả năng thay đổi trạng thái của một tài nguyên giao dịch, điển hình nhất là cơ sở dữ liệu.</p>
                    <p class="mb-4">Mục đích chính của nó trong testing là để đảm bảo tính cô lập của các bài test. Theo mặc định, sau khi một phương thức test được chú thích bằng <code>@Transactional</code> kết thúc, giao dịch sẽ được <strong>rollback (hoàn tác)</strong>. Điều này có nghĩa là mọi thay đổi đối với cơ sở dữ liệu (thêm, sửa, xóa) trong quá trình test sẽ bị hủy bỏ, trả lại cơ sở dữ liệu về trạng thái ban đầu trước khi bài test tiếp theo được chạy.</p>
                    <p class="mb-4">Bạn có thể sử dụng <code>@Transactional</code> ở hai cấp độ:</p>
                    <ul class="list-disc list-inside mb-4 space-y-1">
                        <li>Trên một lớp test: Tất cả các phương thức test trong lớp đó sẽ được chạy trong một giao dịch.</li>
                        <li>Trên một phương thức test: Chỉ phương thức test đó sẽ được chạy trong một giao dịch.</li>
                    </ul>
                    <p>Để kiểm soát hành vi này, bạn có thể sử dụng các annotation bổ sung như <code>@Commit</code> (để buộc commit giao dịch) hoặc <code>@Rollback(false)</code>.</p>
                `
        },
        {
            category: "Spring Test",
            id: "mock-frameworks",
            question: "Các mock framework như Mockito hay EasyMock được sử dụng như thế nào?",
            content: `
                    <p class="mb-4">Các mock framework như Mockito được sử dụng để tạo ra các <strong>đối tượng giả lập (mock objects)</strong>. Mục đích chính là để <strong>cô lập lớp đang được kiểm thử (class under test)</strong> khỏi các thành phần phụ thuộc (collaborators) của nó, chủ yếu trong các bài unit test.</p>
                    <p class="mb-4">Một đối tượng mock có thể \"giả vờ\" là một đối tượng thật và trả về các kết quả được định nghĩa trước khi một phương thức của nó được gọi. Điều này cho phép bạn kiểm tra logic của một lớp mà không cần đến sự hoạt động thực sự của các lớp phụ thuộc. Ngoài ra, mock framework còn cho phép bạn <strong>xác minh (verify)</strong> xem các phương thức mong đợi trên đối tượng mock có được gọi với các tham số chính xác hay không.</p><p class=\"mb-4\">Trong các bài <strong>integration test</strong>, mock cũng có thể được sử dụng để giả lập một phần của hệ thống, ví dụ như một dịch vụ bên ngoài (external API) hoặc một thành phần chưa được triển khai.</p>`
        },
        {
            category: "Spring Test",
            id: "context-configuration",
            question: "<code>@ContextConfiguration</code> được sử dụng như thế nào?",
            content: `
                    <p class="mb-4"><code>@ContextConfiguration</code> là một annotation cốt lõi trong Spring Test Framework, được sử dụng trên một lớp test tích hợp để chỉ định cách tải (load) và cấu hình một <code>ApplicationContext</code> cho bài test đó.</p><p class=\"mb-4\">Đây là cách \"truyền thống\" để thiết lập một integration test trước khi có sự đơn giản hóa của Spring Boot và <code>@SpringBootTest</code>.</p><p class=\"mb-4\"><code>@ContextConfiguration</code> có hai cách tiếp cận chính:</p><ul class=\"list-disc list-inside mb-4 space-y-1\"><li><strong>Dựa trên lớp chú thích (Annotated Classes)</strong>: Bạn cung cấp một hoặc nhiều lớp được chú thích bằng <code>@Configuration</code> cho thuộc tính <code>classes</code>. Spring sẽ sử dụng các lớp này để xây dựng context.</li><li><strong>Dựa trên XML</strong>: Bạn cung cấp đường dẫn đến một hoặc nhiều tệp XML cấu hình Spring cho thuộc tính <code>locations</code>.</li></ul>`
        },
        {
            category: "Spring Test",
            id: "spring-boot-test-simplification",
            question: "Spring Boot đơn giản hóa việc viết test như thế nào?",
            content: "<p class=\"mb-4\">Spring Boot đơn giản hóa đáng kể việc viết test bằng cách cung cấp các tính năng tự động cấu hình và các công cụ tiện lợi.</p><h4 class=\"font-semibold text-lg mb-2\">Các cách chính mà Spring Boot giúp đơn giản hóa việc viết test bao gồm:</h4><ul class=\"list-disc list-inside mb-4 space-y-1\"><li><strong>Cung cấp starter <code>spring-boot-starter-test</code></strong>: Starter này gộp sẵn các thư viện kiểm thử phổ biến nhất như JUnit, Spring Test, Spring Boot Test, AssertJ, Hamcrest, Mockito, và JSONassert.</li><li><strong>Annotation <code>@SpringBootTest</code></strong>: Đây là một annotation \"tất cả trong một\" để chạy các bài test tích hợp. Nó tự động tìm kiếm cấu hình chính của bạn, tạo <code>ApplicationContext</code>, và cung cấp các tính năng của Spring Boot.</li><li><strong>Tự động cấu hình cho test (Test Auto-Configuration)</strong>: Dựa trên các phụ thuộc trong classpath, Spring Boot có thể tự động cấu hình các thành phần cần thiết cho test, ví dụ như một cơ sở dữ liệu trong bộ nhớ (in-memory database).</li><li><strong>Các \"lát cắt\" test (Test Slices)</strong>: Cung cấp các annotation chuyên dụng để chỉ kiểm thử một phần (\"lát cắt\") của ứng dụng, giúp test chạy nhanh hơn (ví dụ: <code>@WebMvcTest</code>, <code>@DataJpaTest</code>, <code>@JsonTest</code>, <code>@RestClientTest</code>).</li><li><strong>Tích hợp Mockito</strong>: Cung cấp các annotation <code>@MockBean</code> và <code>@SpyBean</code> để dễ dàng tạo và tiêm các mock/spy của Mockito vào Spring context.</li></ul>"
        },
        {
            category: "Spring Test",
            id: "spring-boot-test-annotation",
            question: "<code>@SpringBootTest</code> làm gì? Nó tương tác với <code>@SpringBootApplication</code> và <code>@SpringBootConfiguration</code> như thế nào?",
            content: `
                    <p class=\"mb-4\"><code>@SpringBootTest</code> là annotation chính để chạy các bài kiểm thử tích hợp (integration test) trong một ứng dụng Spring Boot. Nó cung cấp các tính năng của Spring Boot lên trên Spring Test Framework thông thường.</p><h4 class=\"font-semibold text-lg mb-2\"><code>@SpringBootTest</code> làm những gì?</h4><ul class=\"list-disc list-inside mb-4 space-y-1\"><li><strong>Tự động tìm kiếm cấu hình</strong>: Nó tự động tìm kiếm một lớp được chú thích bằng <code>@SpringBootConfiguration</code> để sử dụng làm nguồn cấu hình để tải <code>ApplicationContext</code>.</li><li><strong>Tải Context</strong>: Nó sử dụng <code>SpringBootContextLoader</code> để khởi động <code>ApplicationContext</code> thông qua <code>SpringApplication</code>, giống như khi chạy ứng dụng thật.</li><li><strong>Cung cấp các môi trường web</strong>: Cho phép bạn chạy test trong một môi trường web giả lập (<code>MOCK</code> - mặc định), hoặc với một server web thực sự chạy trên một cổng ngẫu nhiên (<code>RANDOM_PORT</code>) hoặc một cổng xác định (<code>DEFINED_PORT</code>).</li><li><strong>Đăng ký các bean cho test</strong>: Tự động đăng ký các bean hữu ích cho việc test như <code>TestRestTemplate</code> hoặc <code>WebTestClient</code> khi cần thiết.</li></ul><h4 class=\"font-semibold text-lg mb-2\">Nó tương tác với <code>@SpringBootApplication</code> và <code>@SpringBootConfiguration</code> như thế nào?</h4><p class=\"mb-4\">Annotation <code>@SpringBootApplication</code> thực chất là một annotation tổng hợp, và một trong những annotation nó chứa là <code>@SpringBootConfiguration</code>.</p><p class=\"mb-4\"><code>@SpringBootConfiguration</code> lại là một dạng thay thế cho <code>@Configuration</code> tiêu chuẩn, với ưu điểm là nó có thể được tự động tìm thấy bởi <code>@SpringBootTest</code>.</p><p class=\"mb-4\">Khi bạn sử dụng <code>@SpringBootTest</code> mà không chỉ định rõ lớp cấu hình nào (<code>classes=...</code>), nó sẽ bắt đầu quét từ gói (package) của lớp test hiện tại và đi ngược lên các gói cha để tìm một lớp được chú thích bằng <code>@SpringBootConfiguration</code> (thường là lớp main của bạn với <code>@SpringBootApplication</code>).</p>`
        }
    ];

    document.addEventListener('DOMContentLoaded', () => {
        try {
            const navigationContainer = document.getElementById('navigation');
            const contentContainer = document.getElementById('content-container');
            const searchBox = document.getElementById('search-box');
            const openSidebarBtn = document.getElementById('open-sidebar-btn');
            const closeSidebarBtn = document.getElementById('close-sidebar-btn');
            const sidebar = document.getElementById('sidebar');

            // Group data by category
            const groupedData = data.reduce((acc, item) => {
                (acc[item.category] = acc[item.category] || []).push(item);
                return acc;
            }, {});

            // Populate navigation and content
            for (const category in groupedData) {
                const categoryNavContainer = document.createElement('div');

                const categoryTitle = document.createElement('h3');
                categoryTitle.className = 'text-lg font-semibold text-amber-800 mb-3';
                categoryTitle.textContent = category;
                categoryNavContainer.appendChild(categoryTitle);

                const navList = document.createElement('ul');
                navList.className = 'space-y-1 border-l-2 border-gray-200';

                groupedData[category].forEach(item => {
                    // Populate navigation
                    const navItem = document.createElement('li');
                    const navLink = document.createElement('a');
                    navLink.href = `#${item.id}`;
                    navLink.textContent = item.question;
                    navLink.className = 'nav-link block text-sm text-gray-600 hover:text-amber-700 py-2 px-4 transition duration-150 rounded-r-md';
                    navLink.dataset.id = item.id;
                    navItem.appendChild(navLink);
                    navList.appendChild(navItem);

                    // Populate content
                    const section = document.createElement('section');
                    section.id = item.id;
                    section.className = 'scroll-mt-20';
                    const title = document.createElement('h2');
                    title.className = 'text-3xl font-bold text-gray-800 mb-6 border-b-2 border-amber-300 pb-2';
                    title.textContent = item.question;
                    const contentDiv = document.createElement('div');
                    contentDiv.className = 'prose max-w-none text-gray-700 leading-relaxed';
                    contentDiv.innerHTML = item.content;
                    section.appendChild(title);
                    section.appendChild(contentDiv);
                    contentContainer.appendChild(section);
                });

                categoryNavContainer.appendChild(navList);
                navigationContainer.appendChild(categoryNavContainer);
            }

            // Search functionality
            searchBox.addEventListener('input', (e) => {
                const searchTerm = e.target.value.toLowerCase();
                document.querySelectorAll('#navigation a').forEach(link => {
                    const questionText = link.textContent.toLowerCase();
                    const parentLi = link.parentElement;
                    if (questionText.includes(searchTerm)) {
                        parentLi.style.display = 'block';
                    } else {
                        parentLi.style.display = 'none';
                    }
                });
            });

            // Smooth scroll for nav links
            document.querySelectorAll('#navigation a').forEach(link => {
                link.addEventListener('click', e => {
                    e.preventDefault();
                    document.querySelector(link.getAttribute('href')).scrollIntoView({
                        behavior: 'smooth'
                    });
                    if (window.innerWidth < 768) {
                        sidebar.classList.add('-translate-x-full');
                    }
                });
            });

            // Intersection Observer for active link highlighting
            const sections = document.querySelectorAll('#content-container section');
            const navLinks = document.querySelectorAll('#navigation a');
            const observer = new IntersectionObserver(entries => {
                entries.forEach(entry => {
                    if (entry.isIntersecting) {
                        navLinks.forEach(link => {
                            link.classList.toggle('active', link.getAttribute('href').substring(1) === entry.target.id);
                        });
                    }
                });
            }, { rootMargin: "-50% 0px -50% 0px" });

            sections.forEach(section => observer.observe(section));

            // Copy button functionality
            document.querySelectorAll('.copy-btn').forEach(button => {
                button.addEventListener('click', () => {
                    const pre = button.nextElementSibling;
                    const code = pre.querySelector('code');
                    if (code) { // Defensive check
                        const textToCopy = code.innerText;

                        // Create a temporary textarea element
                        const tempTextArea = document.createElement('textarea');
                        tempTextArea.value = textToCopy;
                        document.body.appendChild(tempTextArea);

                        // Select the text in the textarea
                        tempTextArea.select();
                        tempTextArea.setSelectionRange(0, 99999); // For mobile devices

                        try {
                            // Copy the text
                            document.execCommand('copy');
                            button.innerHTML = '<i class="fas fa-check"></i> Copied!';
                        } catch (err) {
                            console.error('Failed to copy text using execCommand:', err);
                            button.innerHTML = '<i class="fas fa-times"></i> Failed'; // Indicate failure
                        } finally {
                            // Remove the temporary textarea
                            document.body.removeChild(tempTextArea);
                            setTimeout(() => {
                                button.innerHTML = '<i class="far fa-copy"></i> Copy';
                            }, 2000);
                        }
                    }
                });
            });

            // Mobile sidebar toggle
            openSidebarBtn.addEventListener('click', () => {
                sidebar.classList.remove('-translate-x-full');
            });
            closeSidebarBtn.addEventListener('click', () => {
                sidebar.classList.add('-translate-x-full');
            });
        } catch (error) {
            console.error("An unexpected error occurred during application initialization:", error);
            // You might want to display a more prominent error message to the user here
        }
    });
</script>
</body>
</html>
